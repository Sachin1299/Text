package com.sachin.LearningApp2;


import javax.swing.JFrame;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 *
 * @author Desk
 */
public class Learning_app extends javax.swing.JFrame {

    /**
     * Creates new form Java
     */
    public Learning_app() {
        initComponents();
        setExtendedState(JFrame.MAXIMIZED_BOTH);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel3 = new javax.swing.JPanel();
        HomeButton = new javax.swing.JButton();
        Java1 = new javax.swing.JButton();
        Python1 = new javax.swing.JButton();
        C1 = new javax.swing.JButton();
        C2 = new javax.swing.JButton();
        Cpp = new javax.swing.JButton();
        C = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        jLabel17 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        Home = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        Java = new javax.swing.JButton();
        Python = new javax.swing.JButton();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        Cpp1 = new javax.swing.JButton();
        C3 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jScrollPane6 = new javax.swing.JScrollPane();
        jTextArea5 = new javax.swing.JTextArea();
        jLabel19 = new javax.swing.JLabel();
        JavaContent = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        GetStarted = new javax.swing.JButton();
        j1 = new javax.swing.JButton();
        j2 = new javax.swing.JButton();
        j3 = new javax.swing.JButton();
        j4 = new javax.swing.JButton();
        j5 = new javax.swing.JButton();
        j6 = new javax.swing.JButton();
        j7 = new javax.swing.JButton();
        j8 = new javax.swing.JButton();
        j9 = new javax.swing.JButton();
        j10 = new javax.swing.JButton();
        j11 = new javax.swing.JButton();
        Unit1 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        PythonContent = new javax.swing.JPanel();
        jLabel9 = new javax.swing.JLabel();
        GetStarted1 = new javax.swing.JButton();
        j12 = new javax.swing.JButton();
        j13 = new javax.swing.JButton();
        j14 = new javax.swing.JButton();
        j15 = new javax.swing.JButton();
        j16 = new javax.swing.JButton();
        j17 = new javax.swing.JButton();
        j18 = new javax.swing.JButton();
        j19 = new javax.swing.JButton();
        j20 = new javax.swing.JButton();
        j21 = new javax.swing.JButton();
        j22 = new javax.swing.JButton();
        CppContent = new javax.swing.JPanel();
        jLabel16 = new javax.swing.JLabel();
        GetStarted2 = new javax.swing.JButton();
        cp1 = new javax.swing.JButton();
        j24 = new javax.swing.JButton();
        j25 = new javax.swing.JButton();
        j26 = new javax.swing.JButton();
        j27 = new javax.swing.JButton();
        j28 = new javax.swing.JButton();
        j29 = new javax.swing.JButton();
        j30 = new javax.swing.JButton();
        j31 = new javax.swing.JButton();
        j32 = new javax.swing.JButton();
        CContent = new javax.swing.JPanel();
        jLabel18 = new javax.swing.JLabel();
        GetStarted3 = new javax.swing.JButton();
        j34 = new javax.swing.JButton();
        j35 = new javax.swing.JButton();
        j36 = new javax.swing.JButton();
        j37 = new javax.swing.JButton();
        j38 = new javax.swing.JButton();
        j39 = new javax.swing.JButton();
        j40 = new javax.swing.JButton();
        j41 = new javax.swing.JButton();
        j42 = new javax.swing.JButton();
        j43 = new javax.swing.JButton();
        j44 = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(1366, 730));
        getContentPane().setLayout(null);

        jPanel3.setBackground(new java.awt.Color(223, 106, 106));
        jPanel3.setLayout(null);

        HomeButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/home-icon-silhouette (2).png"))); // NOI18N
        HomeButton.setContentAreaFilled(false);
        HomeButton.setFocusCycleRoot(true);
        HomeButton.setFocusTraversalPolicyProvider(true);
        HomeButton.setSelected(true);
        HomeButton.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                HomeButtonMouseMoved(evt);
            }
        });
        HomeButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                HomeButtonMouseExited(evt);
            }
        });
        HomeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                HomeButtonActionPerformed(evt);
            }
        });
        jPanel3.add(HomeButton);
        HomeButton.setBounds(20, 10, 80, 90);

        Java1.setBackground(new java.awt.Color(255, 255, 255));
        Java1.setForeground(new java.awt.Color(102, 102, 0));
        Java1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/java.png"))); // NOI18N
        Java1.setContentAreaFilled(false);
        Java1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                Java1MouseMoved(evt);
            }
        });
        Java1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                Java1MouseExited(evt);
            }
        });
        Java1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Java1ActionPerformed(evt);
            }
        });
        jPanel3.add(Java1);
        Java1.setBounds(30, 210, 61, 60);

        Python1.setBackground(new java.awt.Color(255, 255, 255));
        Python1.setForeground(new java.awt.Color(102, 102, 0));
        Python1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/python.png"))); // NOI18N
        Python1.setContentAreaFilled(false);
        Python1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        Python1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                Python1MouseMoved(evt);
            }
        });
        Python1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                Python1MouseExited(evt);
            }
        });
        Python1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Python1ActionPerformed(evt);
            }
        });
        jPanel3.add(Python1);
        Python1.setBounds(30, 450, 61, 57);

        C1.setBackground(new java.awt.Color(255, 255, 255));
        C1.setForeground(new java.awt.Color(102, 102, 0));
        C1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/c.png"))); // NOI18N
        C1.setContentAreaFilled(false);
        jPanel3.add(C1);
        C1.setBounds(610, 390, 61, 57);

        C2.setBackground(new java.awt.Color(255, 255, 255));
        C2.setForeground(new java.awt.Color(102, 102, 0));
        C2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/c.png"))); // NOI18N
        C2.setContentAreaFilled(false);
        jPanel3.add(C2);
        C2.setBounds(610, 390, 61, 57);

        Cpp.setBackground(new java.awt.Color(255, 255, 255));
        Cpp.setForeground(new java.awt.Color(102, 102, 0));
        Cpp.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/c (2).png"))); // NOI18N
        Cpp.setContentAreaFilled(false);
        Cpp.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                CppMouseMoved(evt);
            }
        });
        Cpp.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                CppMouseExited(evt);
            }
        });
        Cpp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CppActionPerformed(evt);
            }
        });
        jPanel3.add(Cpp);
        Cpp.setBounds(30, 570, 61, 57);

        C.setBackground(new java.awt.Color(255, 255, 255));
        C.setForeground(new java.awt.Color(102, 102, 0));
        C.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/c.png"))); // NOI18N
        C.setContentAreaFilled(false);
        C.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                CMouseMoved(evt);
            }
        });
        C.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                CMouseExited(evt);
            }
        });
        C.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CActionPerformed(evt);
            }
        });
        jPanel3.add(C);
        C.setBounds(30, 330, 61, 57);
        jPanel3.add(jLabel1);
        jLabel1.setBounds(100, 40, 70, 30);
        jPanel3.add(jLabel2);
        jLabel2.setBounds(90, 240, 50, 30);
        jPanel3.add(jLabel8);
        jLabel8.setBounds(90, 340, 50, 30);
        jPanel3.add(jLabel15);
        jLabel15.setBounds(90, 460, 50, 30);
        jPanel3.add(jLabel17);
        jLabel17.setBounds(90, 580, 50, 30);

        getContentPane().add(jPanel3);
        jPanel3.setBounds(0, 0, 140, 730);

        jPanel1.setBackground(new java.awt.Color(240, 152, 91));
        jPanel1.setLayout(null);

        jTabbedPane1.setBackground(new java.awt.Color(240, 152, 91));
        jTabbedPane1.setTabPlacement(javax.swing.JTabbedPane.BOTTOM);
        jTabbedPane1.setOpaque(true);

        Home.setBackground(java.awt.SystemColor.activeCaption);
        Home.setLayout(null);

        jLabel5.setFont(new java.awt.Font("Consolas", 1, 36)); // NOI18N
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setText("Welcome!!");
        Home.add(jLabel5);
        jLabel5.setBounds(480, 0, 210, 44);

        jLabel6.setFont(new java.awt.Font("Serif", 3, 36)); // NOI18N
        jLabel6.setForeground(new java.awt.Color(255, 255, 255));
        jLabel6.setText("To");
        Home.add(jLabel6);
        jLabel6.setBounds(550, 50, 50, 36);

        jLabel7.setFont(new java.awt.Font("Serif", 3, 36)); // NOI18N
        jLabel7.setForeground(new java.awt.Color(255, 255, 255));
        jLabel7.setText("rogramming");
        Home.add(jLabel7);
        jLabel7.setBounds(460, 100, 204, 48);

        jLabel10.setFont(new java.awt.Font("Segoe Script", 3, 50)); // NOI18N
        jLabel10.setForeground(new java.awt.Color(0, 160, 168));
        jLabel10.setText("P");
        Home.add(jLabel10);
        jLabel10.setBounds(430, 100, 66, 48);

        Java.setBackground(new java.awt.Color(255, 255, 255));
        Java.setForeground(new java.awt.Color(102, 102, 0));
        Java.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/java.png"))); // NOI18N
        Java.setContentAreaFilled(false);
        Java.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                JavaMouseMoved(evt);
            }
        });
        Java.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                JavaMouseExited(evt);
            }
        });
        Java.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                JavaActionPerformed(evt);
            }
        });
        Home.add(Java);
        Java.setBounds(60, 230, 61, 60);

        Python.setBackground(new java.awt.Color(255, 255, 255));
        Python.setForeground(new java.awt.Color(102, 102, 0));
        Python.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/python.png"))); // NOI18N
        Python.setContentAreaFilled(false);
        Python.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        Python.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                PythonMouseMoved(evt);
            }
        });
        Python.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                PythonMouseExited(evt);
            }
        });
        Python.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PythonActionPerformed(evt);
            }
        });
        Home.add(Python);
        Python.setBounds(60, 390, 61, 57);

        jLabel11.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel11.setForeground(new java.awt.Color(255, 255, 255));
        jLabel11.setText("Java");
        Home.add(jLabel11);
        jLabel11.setBounds(70, 290, 60, 20);

        jLabel12.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel12.setForeground(new java.awt.Color(255, 255, 255));
        jLabel12.setText("Python");
        Home.add(jLabel12);
        jLabel12.setBounds(60, 450, 60, 20);

        jLabel13.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel13.setForeground(new java.awt.Color(255, 255, 255));
        jLabel13.setText("C#");
        Home.add(jLabel13);
        jLabel13.setBounds(630, 450, 50, 20);

        jLabel14.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel14.setForeground(new java.awt.Color(255, 255, 255));
        jLabel14.setText("C++");
        Home.add(jLabel14);
        jLabel14.setBounds(620, 280, 60, 20);

        jButton1.setBackground(new java.awt.Color(102, 102, 255));
        jButton1.setContentAreaFilled(false);
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });
        Home.add(jButton1);
        jButton1.setBounds(520, 550, 87, 9);

        Cpp1.setBackground(new java.awt.Color(255, 255, 255));
        Cpp1.setForeground(new java.awt.Color(102, 102, 0));
        Cpp1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/c (2).png"))); // NOI18N
        Cpp1.setContentAreaFilled(false);
        Cpp1.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                Cpp1MouseMoved(evt);
            }
        });
        Cpp1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                Cpp1MouseExited(evt);
            }
        });
        Cpp1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Cpp1ActionPerformed(evt);
            }
        });
        Home.add(Cpp1);
        Cpp1.setBounds(610, 220, 61, 57);

        C3.setBackground(new java.awt.Color(255, 255, 255));
        C3.setForeground(new java.awt.Color(102, 102, 0));
        C3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resources/c.png"))); // NOI18N
        C3.setContentAreaFilled(false);
        C3.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                C3MouseMoved(evt);
            }
        });
        C3.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                C3MouseExited(evt);
            }
        });
        C3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                C3ActionPerformed(evt);
            }
        });
        Home.add(C3);
        C3.setBounds(610, 390, 61, 57);

        jButton2.setIcon(new javax.swing.ImageIcon("C:\\Users\\DELL\\Downloads\\logout.png")); // NOI18N
        jButton2.setContentAreaFilled(false);
        jButton2.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                jButton2MouseMoved(evt);
            }
        });
        jButton2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseExited(java.awt.event.MouseEvent evt) {
                jButton2MouseExited(evt);
            }
        });
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        Home.add(jButton2);
        jButton2.setBounds(580, 533, 90, 80);

        jScrollPane3.setBorder(null);
        jScrollPane3.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane3.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
        jScrollPane3.setEnabled(false);
        jScrollPane3.setFocusable(false);
        jScrollPane3.setOpaque(false);
        jScrollPane3.setVerifyInputWhenFocusTarget(false);
        jScrollPane3.setWheelScrollingEnabled(false);

        jTextArea2.setEditable(false);
        jTextArea2.setBackground(java.awt.SystemColor.activeCaption);
        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jTextArea2.setAutoscrolls(false);
        jTextArea2.setBorder(null);
        jTextArea2.setDebugGraphicsOptions(javax.swing.DebugGraphics.NONE_OPTION);
        jTextArea2.setHighlighter(null);
        jTextArea2.setKeymap(null);
        jTextArea2.setOpaque(false);
        jScrollPane3.setViewportView(jTextArea2);

        Home.add(jScrollPane3);
        jScrollPane3.setBounds(130, 240, 300, 110);

        jScrollPane4.setBorder(null);
        jScrollPane4.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane4.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
        jScrollPane4.setEnabled(false);
        jScrollPane4.setFocusable(false);
        jScrollPane4.setOpaque(false);
        jScrollPane4.setVerifyInputWhenFocusTarget(false);
        jScrollPane4.setWheelScrollingEnabled(false);

        jTextArea3.setEditable(false);
        jTextArea3.setBackground(java.awt.SystemColor.activeCaption);
        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jTextArea3.setAutoscrolls(false);
        jTextArea3.setBorder(null);
        jTextArea3.setDebugGraphicsOptions(javax.swing.DebugGraphics.NONE_OPTION);
        jTextArea3.setHighlighter(null);
        jTextArea3.setKeymap(null);
        jTextArea3.setOpaque(false);
        jScrollPane4.setViewportView(jTextArea3);

        Home.add(jScrollPane4);
        jScrollPane4.setBounds(130, 390, 300, 110);

        jScrollPane5.setBorder(null);
        jScrollPane5.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane5.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
        jScrollPane5.setEnabled(false);
        jScrollPane5.setFocusable(false);
        jScrollPane5.setOpaque(false);
        jScrollPane5.setVerifyInputWhenFocusTarget(false);
        jScrollPane5.setWheelScrollingEnabled(false);

        jTextArea4.setEditable(false);
        jTextArea4.setBackground(java.awt.SystemColor.activeCaption);
        jTextArea4.setColumns(20);
        jTextArea4.setRows(5);
        jTextArea4.setAutoscrolls(false);
        jTextArea4.setBorder(null);
        jTextArea4.setDebugGraphicsOptions(javax.swing.DebugGraphics.NONE_OPTION);
        jTextArea4.setHighlighter(null);
        jTextArea4.setKeymap(null);
        jTextArea4.setOpaque(false);
        jScrollPane5.setViewportView(jTextArea4);

        Home.add(jScrollPane5);
        jScrollPane5.setBounds(680, 220, 360, 110);

        jScrollPane6.setBorder(null);
        jScrollPane6.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane6.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
        jScrollPane6.setEnabled(false);
        jScrollPane6.setFocusable(false);
        jScrollPane6.setOpaque(false);
        jScrollPane6.setVerifyInputWhenFocusTarget(false);
        jScrollPane6.setWheelScrollingEnabled(false);

        jTextArea5.setEditable(false);
        jTextArea5.setBackground(java.awt.SystemColor.activeCaption);
        jTextArea5.setColumns(20);
        jTextArea5.setRows(5);
        jTextArea5.setAutoscrolls(false);
        jTextArea5.setBorder(null);
        jTextArea5.setDebugGraphicsOptions(javax.swing.DebugGraphics.NONE_OPTION);
        jTextArea5.setHighlighter(null);
        jTextArea5.setKeymap(null);
        jTextArea5.setOpaque(false);
        jScrollPane6.setViewportView(jTextArea5);

        Home.add(jScrollPane6);
        jScrollPane6.setBounds(680, 390, 360, 120);
        Home.add(jLabel19);
        jLabel19.setBounds(660, 550, 70, 30);

        jTabbedPane1.addTab("home", Home);

        JavaContent.setBackground(new java.awt.Color(240, 152, 143));
        JavaContent.setLayout(null);

        jLabel4.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        jLabel4.setText("Content");
        JavaContent.add(jLabel4);
        jLabel4.setBounds(480, 0, 150, 40);

        GetStarted.setBackground(new java.awt.Color(51, 255, 51));
        GetStarted.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        GetStarted.setText("Get Started");
        GetStarted.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GetStartedActionPerformed(evt);
            }
        });
        JavaContent.add(GetStarted);
        GetStarted.setBounds(1090, 530, 130, 60);

        j1.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j1.setText("1. Overview of Java");
        j1.setContentAreaFilled(false);
        j1.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j1ActionPerformed(evt);
            }
        });
        JavaContent.add(j1);
        j1.setBounds(0, 150, 250, 37);

        j2.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j2.setText("2. Hello world Program");
        j2.setContentAreaFilled(false);
        j2.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j2ActionPerformed(evt);
            }
        });
        JavaContent.add(j2);
        j2.setBounds(0, 190, 290, 37);

        j3.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j3.setText("3. Data Types");
        j3.setContentAreaFilled(false);
        j3.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j3ActionPerformed(evt);
            }
        });
        JavaContent.add(j3);
        j3.setBounds(0, 230, 250, 37);

        j4.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j4.setText("4. Operators");
        j4.setContentAreaFilled(false);
        j4.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j4ActionPerformed(evt);
            }
        });
        JavaContent.add(j4);
        j4.setBounds(0, 270, 250, 37);

        j5.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j5.setText("5. Statements and Flow Control");
        j5.setContentAreaFilled(false);
        j5.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j5ActionPerformed(evt);
            }
        });
        JavaContent.add(j5);
        j5.setBounds(0, 310, 380, 37);

        j6.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j6.setText("6. Object Oriented Programming");
        j6.setContentAreaFilled(false);
        j6.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j6ActionPerformed(evt);
            }
        });
        JavaContent.add(j6);
        j6.setBounds(0, 350, 380, 37);

        j7.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j7.setText("7. Packaging");
        j7.setContentAreaFilled(false);
        j7.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j7ActionPerformed(evt);
            }
        });
        JavaContent.add(j7);
        j7.setBounds(0, 390, 380, 37);

        j8.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j8.setText("8. JavaDoc");
        j8.setContentAreaFilled(false);
        j8.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j8ActionPerformed(evt);
            }
        });
        JavaContent.add(j8);
        j8.setBounds(0, 430, 380, 37);

        j9.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j9.setText("9. Exceptions");
        j9.setContentAreaFilled(false);
        j9.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j9.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j9ActionPerformed(evt);
            }
        });
        JavaContent.add(j9);
        j9.setBounds(0, 470, 380, 37);

        j10.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j10.setText("10. Input Output");
        j10.setContentAreaFilled(false);
        j10.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j10ActionPerformed(evt);
            }
        });
        JavaContent.add(j10);
        j10.setBounds(-10, 510, 380, 37);

        j11.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j11.setText("11. Threading");
        j11.setContentAreaFilled(false);
        j11.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j11.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j11ActionPerformed(evt);
            }
        });
        JavaContent.add(j11);
        j11.setBounds(-10, 550, 380, 37);

        jTabbedPane1.addTab("java1", JavaContent);

        Unit1.setBackground(java.awt.SystemColor.activeCaption);

        jScrollPane2.setBackground(new java.awt.Color(223, 106, 106));
        jScrollPane2.setBorder(null);
        jScrollPane2.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane2.setFocusable(false);
        jScrollPane2.setOpaque(false);
        jScrollPane2.setViewportView(null);

        jTextPane1.setEditable(false);
        jTextPane1.setBackground(new java.awt.Color(223, 106, 106));
        jTextPane1.setBorder(null);
        jTextPane1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jTextPane1.setAutoscrolls(false);
        jTextPane1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jTextPane1.setFocusCycleRoot(false);
        jTextPane1.setName(""); // NOI18N
        jTextPane1.setOpaque(false);
        jScrollPane2.setViewportView(jTextPane1);

        javax.swing.GroupLayout Unit1Layout = new javax.swing.GroupLayout(Unit1);
        Unit1.setLayout(Unit1Layout);
        Unit1Layout.setHorizontalGroup(
            Unit1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Unit1Layout.createSequentialGroup()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 1215, Short.MAX_VALUE)
                .addContainerGap())
        );
        Unit1Layout.setVerticalGroup(
            Unit1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Unit1Layout.createSequentialGroup()
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 605, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        jScrollPane2.setBackground(new java.awt.Color(223, 133, 133));
        jTextPane1.setBackground(new java.awt.Color(223, 133, 133));

        jTabbedPane1.addTab("java2", Unit1);

        PythonContent.setBackground(new java.awt.Color(240, 152, 143));
        PythonContent.setLayout(null);

        jLabel9.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        jLabel9.setText("Content");
        PythonContent.add(jLabel9);
        jLabel9.setBounds(480, 10, 150, 40);

        GetStarted1.setBackground(new java.awt.Color(51, 255, 51));
        GetStarted1.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        GetStarted1.setText("Get Started");
        GetStarted1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GetStarted1ActionPerformed(evt);
            }
        });
        PythonContent.add(GetStarted1);
        GetStarted1.setBounds(1090, 530, 130, 60);

        j12.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j12.setText("1. Getting Started");
        j12.setContentAreaFilled(false);
        j12.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j12.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j12ActionPerformed(evt);
            }
        });
        PythonContent.add(j12);
        j12.setBounds(0, 150, 250, 37);

        j13.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j13.setText("2. Types");
        j13.setContentAreaFilled(false);
        j13.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j13.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j13ActionPerformed(evt);
            }
        });
        PythonContent.add(j13);
        j13.setBounds(0, 190, 290, 37);

        j14.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j14.setText("3. Variables");
        j14.setContentAreaFilled(false);
        j14.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j14.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j14ActionPerformed(evt);
            }
        });
        PythonContent.add(j14);
        j14.setBounds(0, 230, 250, 37);

        j15.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j15.setText("4. Simple Expressions");
        j15.setContentAreaFilled(false);
        j15.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j15.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j15ActionPerformed(evt);
            }
        });
        PythonContent.add(j15);
        j15.setBounds(0, 270, 370, 37);

        j16.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j16.setText("5. Advanced Types: Containers");
        j16.setContentAreaFilled(false);
        j16.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j16.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j16ActionPerformed(evt);
            }
        });
        PythonContent.add(j16);
        j16.setBounds(0, 310, 380, 37);

        j17.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j17.setText("6. A Bit More Iteration");
        j17.setContentAreaFilled(false);
        j17.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j17.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j17ActionPerformed(evt);
            }
        });
        PythonContent.add(j17);
        j17.setBounds(0, 350, 380, 37);

        j18.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j18.setText("7. Functions");
        j18.setContentAreaFilled(false);
        j18.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j18.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j18ActionPerformed(evt);
            }
        });
        PythonContent.add(j18);
        j18.setBounds(0, 390, 380, 37);

        j19.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j19.setText("8. Exceptions");
        j19.setContentAreaFilled(false);
        j19.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j19.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j19ActionPerformed(evt);
            }
        });
        PythonContent.add(j19);
        j19.setBounds(0, 430, 380, 37);

        j20.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j20.setText("9. Code Organization");
        j20.setContentAreaFilled(false);
        j20.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j20.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j20ActionPerformed(evt);
            }
        });
        PythonContent.add(j20);
        j20.setBounds(0, 470, 380, 37);

        j21.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j21.setText("10. Working with Files");
        j21.setContentAreaFilled(false);
        j21.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j21.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j21ActionPerformed(evt);
            }
        });
        PythonContent.add(j21);
        j21.setBounds(-10, 510, 380, 37);

        j22.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j22.setText("11. Interacting with the Outside World");
        j22.setContentAreaFilled(false);
        j22.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j22.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j22ActionPerformed(evt);
            }
        });
        PythonContent.add(j22);
        j22.setBounds(-10, 550, 480, 37);

        jTabbedPane1.addTab("java1", PythonContent);

        CppContent.setBackground(new java.awt.Color(240, 152, 143));
        CppContent.setLayout(null);

        jLabel16.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        jLabel16.setText("Content");
        CppContent.add(jLabel16);
        jLabel16.setBounds(480, 0, 150, 40);

        GetStarted2.setBackground(new java.awt.Color(51, 255, 51));
        GetStarted2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        GetStarted2.setText("Get Started");
        GetStarted2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GetStarted2ActionPerformed(evt);
            }
        });
        CppContent.add(GetStarted2);
        GetStarted2.setBounds(1090, 530, 130, 60);

        cp1.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        cp1.setText("1. Introduction");
        cp1.setContentAreaFilled(false);
        cp1.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        cp1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cp1ActionPerformed(evt);
            }
        });
        CppContent.add(cp1);
        cp1.setBounds(0, 150, 250, 37);

        j24.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j24.setText("2. Basic C++ Elements");
        j24.setContentAreaFilled(false);
        j24.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j24.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j24ActionPerformed(evt);
            }
        });
        CppContent.add(j24);
        j24.setBounds(0, 190, 290, 37);

        j25.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j25.setText("3. Input/Output");
        j25.setContentAreaFilled(false);
        j25.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j25.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j25ActionPerformed(evt);
            }
        });
        CppContent.add(j25);
        j25.setBounds(0, 230, 250, 37);

        j26.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j26.setText("4. Selection Structures");
        j26.setContentAreaFilled(false);
        j26.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j26.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j26ActionPerformed(evt);
            }
        });
        CppContent.add(j26);
        j26.setBounds(0, 270, 310, 37);

        j27.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j27.setText("5. Repetition Structures");
        j27.setContentAreaFilled(false);
        j27.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j27.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j27ActionPerformed(evt);
            }
        });
        CppContent.add(j27);
        j27.setBounds(0, 310, 380, 37);

        j28.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j28.setText("6. Functions 1 - Predefined and Value-Returning Functions");
        j28.setContentAreaFilled(false);
        j28.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j28.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j28ActionPerformed(evt);
            }
        });
        CppContent.add(j28);
        j28.setBounds(0, 350, 670, 37);

        j29.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j29.setText("7. Functions 2 - Void (NonValue-Returning) Functions");
        j29.setContentAreaFilled(false);
        j29.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j29.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j29ActionPerformed(evt);
            }
        });
        CppContent.add(j29);
        j29.setBounds(0, 390, 640, 37);

        j30.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j30.setText("8. UDTs (User-Defined Types), Namespaces, and string Type");
        j30.setContentAreaFilled(false);
        j30.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j30.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j30ActionPerformed(evt);
            }
        });
        CppContent.add(j30);
        j30.setBounds(0, 430, 700, 37);

        j31.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j31.setText("9. Data Types, Arrays and Strings");
        j31.setContentAreaFilled(false);
        j31.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j31.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j31ActionPerformed(evt);
            }
        });
        CppContent.add(j31);
        j31.setBounds(0, 470, 560, 37);

        j32.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j32.setText("10. Pointers");
        j32.setContentAreaFilled(false);
        j32.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j32.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j32ActionPerformed(evt);
            }
        });
        CppContent.add(j32);
        j32.setBounds(-10, 510, 380, 37);

        jTabbedPane1.addTab("java1", CppContent);

        CContent.setBackground(new java.awt.Color(240, 152, 143));
        CContent.setLayout(null);

        jLabel18.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        jLabel18.setText("Contents");
        CContent.add(jLabel18);
        jLabel18.setBounds(490, 0, 150, 40);

        GetStarted3.setBackground(new java.awt.Color(51, 255, 51));
        GetStarted3.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        GetStarted3.setText("Get Started");
        GetStarted3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GetStarted3ActionPerformed(evt);
            }
        });
        CContent.add(GetStarted3);
        GetStarted3.setBounds(1090, 530, 130, 60);

        j34.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j34.setText("1. Overview ");
        j34.setContentAreaFilled(false);
        j34.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j34.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j34ActionPerformed(evt);
            }
        });
        CContent.add(j34);
        j34.setBounds(0, 150, 250, 37);

        j35.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j35.setText("2. Hello world Program");
        j35.setContentAreaFilled(false);
        j35.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j35.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j35ActionPerformed(evt);
            }
        });
        CContent.add(j35);
        j35.setBounds(0, 190, 290, 37);

        j36.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j36.setText("3. Data Types");
        j36.setContentAreaFilled(false);
        j36.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j36.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j36ActionPerformed(evt);
            }
        });
        CContent.add(j36);
        j36.setBounds(0, 230, 250, 37);

        j37.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j37.setText("4. Operators");
        j37.setContentAreaFilled(false);
        j37.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j37.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j37ActionPerformed(evt);
            }
        });
        CContent.add(j37);
        j37.setBounds(0, 270, 250, 37);

        j38.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j38.setText("5. Statements and Flow Control");
        j38.setContentAreaFilled(false);
        j38.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j38.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j38ActionPerformed(evt);
            }
        });
        CContent.add(j38);
        j38.setBounds(0, 310, 380, 37);

        j39.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j39.setText("6. Procedure Oriented Programming");
        j39.setContentAreaFilled(false);
        j39.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j39.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j39ActionPerformed(evt);
            }
        });
        CContent.add(j39);
        j39.setBounds(0, 350, 440, 37);

        j40.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j40.setText("7. Packaging");
        j40.setContentAreaFilled(false);
        j40.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j40.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j40ActionPerformed(evt);
            }
        });
        CContent.add(j40);
        j40.setBounds(0, 390, 380, 37);

        j41.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j41.setText("8. Preprocessor");
        j41.setContentAreaFilled(false);
        j41.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j41.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j41ActionPerformed(evt);
            }
        });
        CContent.add(j41);
        j41.setBounds(0, 430, 380, 37);

        j42.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j42.setText("9. Exceptions");
        j42.setContentAreaFilled(false);
        j42.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j42.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j42ActionPerformed(evt);
            }
        });
        CContent.add(j42);
        j42.setBounds(0, 470, 380, 37);

        j43.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j43.setText("10. Input Output");
        j43.setContentAreaFilled(false);
        j43.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j43.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j43ActionPerformed(evt);
            }
        });
        CContent.add(j43);
        j43.setBounds(-10, 510, 380, 37);

        j44.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        j44.setText("11. Threading");
        j44.setContentAreaFilled(false);
        j44.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        j44.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                j44ActionPerformed(evt);
            }
        });
        CContent.add(j44);
        j44.setBounds(-10, 550, 380, 37);

        jTabbedPane1.addTab("java1", CContent);

        jPanel1.add(jTabbedPane1);
        jTabbedPane1.setBounds(0, 0, 1230, 660);

        getContentPane().add(jPanel1);
        jPanel1.setBounds(140, 100, 1230, 630);

        jPanel2.setBackground(new java.awt.Color(223, 106, 106));
        jPanel2.setLayout(null);

        jLabel3.setFont(new java.awt.Font("Lucida Handwriting", 0, 50)); // NOI18N
        jLabel3.setForeground(new java.awt.Color(12, 175, 175));
        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel3.setText("Programming");
        jPanel2.add(jLabel3);
        jLabel3.setBounds(150, 10, 820, 80);

        getContentPane().add(jPanel2);
        jPanel2.setBounds(140, 0, 1230, 100);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void HomeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_HomeButtonActionPerformed
        jTabbedPane1.setSelectedIndex(0);  
        jLabel3.setText("Programming");
    }//GEN-LAST:event_HomeButtonActionPerformed

    private void GetStartedActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GetStartedActionPerformed
       jTextPane1.setText("Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems' Java platform (Java 1.0 [J2SE]).\n\nThe latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suit various types of platforms. For example: J2EE for Enterprise Applications, J2ME for Mobile Applications.\n\nThe new J2 versions were renamed as Java SE, Java EE, and Java ME respectively. Java is guaranteed to be Write Once, Run Anywhere.\n\nJava is \n\nObject Oriented  In Java, everything is an Object. Java can be easily extended since it is based on the Object model.\n\nPlatform Independent  Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by the Virtual Machine (JVM) on whichever platform it is being run on.\n\nSimple  Java is designed to be easy to learn. If you understand the basic concept of OOP Java, it would be easy to master.\n\nSecure  With Java's secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.\n\nArchitecture-neutral  Java compiler generates an architecture-neutral object file format, which makes the compiled code executable on many processors, with the presence of Java runtime system.\n\nPortable  Being architecture-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary, which is a POSIX subset.\n\nRobust  Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.\n\nMultithreaded  With Java's multithreaded feature it is possible to write programs that can perform many tasks simultaneously. This design feature allows the developers to construct interactive applications that can run smoothly.\n\nInterpreted  Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light-weight process.\n\nHigh Performance  With the use of Just-In-Time compilers, Java enables high performance.\n\nDistributed  Java is designed for the distributed environment of the internet.\n\nDynamic  Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve \naccesses to objects on run-time.\n\n\n\nHistory of Java\n\nJames Gosling initiated Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Gosling's office, also went by the name Green and ended up later being renamed as Java, from a list of random words.\n\nSun released the first public implementation as Java 1.0 in 1995. It promised Write Once, Run Anywhere (WORA), providing no-cost run-times on popular platforms.\n\nOn 13 November, 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).\n\nOn 8 May, 2007, Sun finished the process, making all of Java's core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.\n\nTools You Will Need\nFor performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).\n\nYou will also need the following softwares \n\nLinux 7.1 or Windows xp/7/8 operating system\nJava JDK 8\nMicrosoft Notepad or any other text editor\nThis tutorial will provide the necessary skills to create GUI, networking, and web applications using Java.");
        setContent("                                    1.Overview of Java\n\n");
        jTabbedPane1.setSelectedIndex(2);   // TODO add your handling code here:
    }//GEN-LAST:event_GetStartedActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
    	  ApplicationContext ac=new ClassPathXmlApplicationContext("Configuration.xml");
          Login f=ac.getBean("login",Login.class);
          this.setVisible(false);
          f.setVisible(true);
    }//GEN-LAST:event_jButton1ActionPerformed
 
    private void JavaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_JavaActionPerformed
       
        jTabbedPane1.setSelectedIndex(1);
            jLabel3.setText("Java");
// TODO add your handling code here:
    }//GEN-LAST:event_JavaActionPerformed

    private void Java1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Java1ActionPerformed
       jTabbedPane1.setSelectedIndex(1); 
        jLabel3.setText("JAVA");
       // TODO add your handling code here:
    }//GEN-LAST:event_Java1ActionPerformed

    private void Cpp1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Cpp1ActionPerformed
        jLabel3.setText("C++");
        jTabbedPane1.setSelectedIndex(4);
    }//GEN-LAST:event_Cpp1ActionPerformed

    private void CppActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CppActionPerformed
       jLabel3.setText("C++"); 
       jTabbedPane1.setSelectedIndex(4);// TODO add your handling code here:
    }//GEN-LAST:event_CppActionPerformed

    private void C3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_C3ActionPerformed
        jLabel3.setText("C"); 
        jTabbedPane1.setSelectedIndex(5);// TODO add your handling code here:
    }//GEN-LAST:event_C3ActionPerformed

    private void CActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CActionPerformed
       jLabel3.setText("C"); 
       jTabbedPane1.setSelectedIndex(5);// TODO add your handling code here:
    }//GEN-LAST:event_CActionPerformed

    private void Python1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Python1ActionPerformed
       jLabel3.setText("Python"); 
        jTabbedPane1.setSelectedIndex(3);// TODO add your handling code here:
    }//GEN-LAST:event_Python1ActionPerformed

    private void PythonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PythonActionPerformed
       jLabel3.setText("Python"); 
       jTabbedPane1.setSelectedIndex(3);// TODO add your handling code here:
    }//GEN-LAST:event_PythonActionPerformed

    private void j1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j1ActionPerformed
       jScrollPane2.setBackground(new java.awt.Color(223, 133, 133));
       jTextPane1.setBackground(new java.awt.Color(223, 133, 133));
        jTextPane1.setBackground(new java.awt.Color(223, 133, 133));
        jTextPane1.setText("Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems' Java platform (Java 1.0 [J2SE]).\n\nThe latest release of the Java Standard Edition is Java SE 8. With the advancement of Java and its widespread popularity, multiple configurations were built to suit various types of platforms. For example: J2EE for Enterprise Applications, J2ME for Mobile Applications.\n\nThe new J2 versions were renamed as Java SE, Java EE, and Java ME respectively. Java is guaranteed to be Write Once, Run Anywhere.\n\nJava is \n\nObject Oriented  In Java, everything is an Object. Java can be easily extended since it is based on the Object model.\n\nPlatform Independent  Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by the Virtual Machine (JVM) on whichever platform it is being run on.\n\nSimple  Java is designed to be easy to learn. If you understand the basic concept of OOP Java, it would be easy to master.\n\nSecure  With Java's secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.\n\nArchitecture-neutral  Java compiler generates an architecture-neutral object file format, which makes the compiled code executable on many processors, with the presence of Java runtime system.\n\nPortable  Being architecture-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary, which is a POSIX subset.\n\nRobust  Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.\n\nMultithreaded  With Java's multithreaded feature it is possible to write programs that can perform many tasks simultaneously. This design feature allows the developers to construct interactive applications that can run smoothly.\n\nInterpreted  Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light-weight process.\n\nHigh Performance  With the use of Just-In-Time compilers, Java enables high performance.\n\nDistributed  Java is designed for the distributed environment of the internet.\n\nDynamic  Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve \naccesses to objects on run-time.\n\n\n\nHistory of Java\n\nJames Gosling initiated Java language project in June 1991 for use in one of his many set-top box projects. The language, initially called Oak after an oak tree that stood outside Gosling's office, also went by the name Green and ended up later being renamed as Java, from a list of random words.\n\nSun released the first public implementation as Java 1.0 in 1995. It promised Write Once, Run Anywhere (WORA), providing no-cost run-times on popular platforms.\n\nOn 13 November, 2006, Sun released much of Java as free and open source software under the terms of the GNU General Public License (GPL).\n\nOn 8 May, 2007, Sun finished the process, making all of Java's core code free and open-source, aside from a small portion of code to which Sun did not hold the copyright.\n\nTools You Will Need\nFor performing the examples discussed in this tutorial, you will need a Pentium 200-MHz computer with a minimum of 64 MB of RAM (128 MB of RAM recommended).\n\nYou will also need the following softwares \n\nLinux 7.1 or Windows xp/7/8 operating system\nJava JDK 8\nMicrosoft Notepad or any other text editor\nThis tutorial will provide the necessary skills to create GUI, networking, and web applications using Java.");
        setContent("                                    1.Overview of Java\n\n");
        jScrollPane2.setBackground(new java.awt.Color(223, 133, 133));
        jTextPane1.setBackground(new java.awt.Color(223, 133, 133));
        jTabbedPane1.setSelectedIndex(2); 
        // TODO add your handling code here:
    }//GEN-LAST:event_j1ActionPerformed

    private void j2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j2ActionPerformed

        jTextPane1.setText("class Sample \n{\npublic static void main(String args[])\n{\nSystem.out.print(\"Hello World\");\n}\n}");
        setContent("                                    2.Hello World Program\n\n");
        jTabbedPane1.setSelectedIndex(2);
        // TODO add your handling code here:
    }//GEN-LAST:event_j2ActionPerformed

    private void j3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j3ActionPerformed
    
       
        jTextPane1.setText("Data types are divided into two groups:\n\nPrimitive data types - includes byte, short, int, long, float, double, boolean and char\nNon-primitive data types - such as String, Arrays and Classes (you will learn more about these in a later chapter)\n\nPrimitive Data Types\nA primitive data type specifies the size and type of variable values, and it has no additional methods.\n\nThere are eight primitive data types in Java:\n\nData Type\tSize\tDescription\nbyte\t1 byte\tStores whole numbers from -128 to 127\nshort\t2 bytes\tStores whole numbers from -32,768 to 32,767\nint\t4 bytes\tStores whole numbers from -2,147,483,648 to 2,147,483,647\nlong\t8 bytes\tStores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807\nfloat\t4 bytes\tStores fractional numbers. Sufficient for storing 6 to 7 decimal digits\ndouble\t8 bytes\tStores fractional numbers. Sufficient for storing 15 decimal digits\nboolean\t1 bit\tStores true or false values\nchar\t2 bytes\tStores a single character/letter or ASCII values\n\n\nNumbers\nPrimitive number types are divided into two groups:\n\nInteger types stores whole numbers, positive or negative (such as 123 or -456), without decimals. Valid types are byte, short, int and long. Which type you should use, depends on the numeric value.\n\nInteger Types\nByte\nThe byte data type can store whole numbers from -128 to 127. This can be used instead of int or other integer types to save memory when you are certain that the value will be within -128 and 127:\n\nInt\nThe int data type can store whole numbers from -2147483648 to 2147483647. In general, and in our tutorial, the int data type is the preferred data type when we create variables with a numeric value.\n\nLong\nThe long data type can store whole numbers from -9223372036854775808 to 9223372036854775807. This is used when int is not large enough to store the value. Note that you should end the value with an \"L\":\n\n\nFloating Point Types\nYou should use a floating point type whenever you need a number with a decimal, such as 9.99 or 3.14515.\n\nFloat\nThe float data type can store fractional numbers from 3.4e038 to 3.4e+038. Note that you should end the value with an \"f\":\n\nFloating point types represents numbers with a fractional part, containing one or more decimals. There are two types: float and double.\n\nDouble\nThe double data type can store fractional numbers from 1.7e308 to 1.7e+308. Note that you should end the value with a \"d\":\n\nScientific Numbers\nA floating point number can also be a scientific number with an \"e\" to indicate the power of 10:\n\nBooleans\nA boolean data type is declared with the boolean keyword and can only take the values true or false:\nBoolean values are mostly used for conditional testing, which you will learn more about in a later chapter.\n\nCharacters\nThe char data type is used to store a single character. The character must be surrounded by single quotes, like 'A' or 'c':\n\nStrings\nThe String data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:\n\n\n\n     Non-Primitive Data Types\nNon-primitive data types are called reference types because they refer to objects.\n\nThe main difference between primitive and non-primitive data types are:\n\nPrimitive types are predefined (already defined) in Java. Non-primitive types are created by the programmer and is not defined by Java (except for String).\nNon-primitive types can be used to call methods to perform certain operations, while primitive types cannot.\nA primitive type has always a value, while non-primitive types can be null.\nA primitive type starts with a lowercase letter, while non-primitive types starts with an uppercase letter.\nThe size of a primitive type depends on the data type, while non-primitive types have all the same size.\nExamples of non-primitive types are Strings, Arrays, Classes, Interface, etc. You will learn more about these in a later chapter.");
        setContent("                                    3.Data Types\n\n");
        jTabbedPane1.setSelectedIndex(2);
        
    }//GEN-LAST:event_j3ActionPerformed

    private void j4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j4ActionPerformed
        
        jTextPane1.setText("Operator in Java is a symbol which is used to perform operations. For example: +, -, *, / etc.\n\n\nThere are many types of operators in Java which are given below:\n\n->Unary Operator,\n->Arithmetic Operator,\n->Shift Operator,\n->Relational Operator,\n->Bitwise Operator,\n->Logical Operator,\n->Ternary Operator and\n->Assignment Operator.\n\n\nJava Operator Precedence\n\nOperator Type\tCategory\t                      Precedence\nUnary\t                      postfix\t                      expr++ expr--\n                                            prefix\t          ++expr --expr +expr -expr ~ !\nArithmetic\t                  multiplicative\t                           * / %\n                                           additive\t                             + -\nShift\t                         shift\t                     << >> >>>\nRelational\t                    comparison\t             < > <= >= instanceof\n                                           equality\t                           == !=\nBitwise\t                  bitwise AND\t                              &\n                                bitwise exclusive OR\t         ^\n                                 bitwise inclusive OR\t          |\nLogical\t                  logical AND\t                              &&\n                                        logical OR\t                               ||\nTernary\t                     ternary\t                                ? :\nAssignment\t                    assignment\t  = += -= *= /= %= &= ^= |= <<= >>= >>>=\n\n\n\nJava Unary Operator :- The Java unary operators require only one operand. Unary operators are used to perform various operations i.e.:\n\n->incrementing/decrementing a value by one\n->negating an expression\n->inverting the value of a boolean\n\n\n\nJava Arithmetic Operators :- Java arithmatic operators are used to perform addition, subtraction, multiplication, and division. They act as basic mathematical operations.\n\nJava Left Shift Operator :- The Java left shift operator << is used to shift all of the bits in a value to the left side of a specified number of times.\n\nJava Right Shift Operator :- The Java right shift operator >> is used to move left operands value to right by the number of bits specified by the right operand.\n\n\n\nJava AND Operator Example: Logical && and Bitwise &\nThe logical && operator doesn't check second condition if first condition is false. It checks second condition only if first one is true.\n\nThe bitwise & operator always checks both conditions whether first condition is true or false.\n\n\n\nJava OR Operator Example: Logical || and Bitwise |\nThe logical || operator doesn't check second condition if first condition is true. It checks second condition only if first one is false.\n\nThe bitwise | operator always checks both conditions whether first condition is true or false.\n\n\nJava Ternary Operator :- Java Ternary operator is used as one liner replacement for if-then-else statement and used a lot in Java programming. it is the only conditional operator which takes three operands.\n\n\nJava Assignment Operator :- Java assignment operator is one of the most common operator. It is used to assign the value on its right to the operand on its left.");
        setContent("                                    4.Operators\n\n");
        jTabbedPane1.setSelectedIndex(2);
       
    }//GEN-LAST:event_j4ActionPerformed

    private void j5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j5ActionPerformed
               jTextPane1.setText("Java Control Flow Statements  :-  Control flow or flow of control is the order in which instructions, statements and function calls being executed or evaluated when a program is running. The control flow statements are also called as Flow Control Statements. In Java, statements inside your code are generally executed sequentially from top to bottom, in the order that they appear. It is not always the case your program statements to be executed straightforward one after another sequentially, you may require to execute or skip certain set of instructions based on condition, jump to another statements, or execute a set of statements repeatedly. In Java, control flow statements are used to alter, redirect, or to control the flow of program execution based on the application logic\n\nJava Control Flow Statement Types\nIn Java, Control flow statements are mainly categorized in following types \n\n->Selection statements\n->Iteration statements\n->Jump statements\n\nJava Selection Statements\nIn Java, Selection statements allow you to control the flow of the program during run time on the basis of the outcome of an expression or state of a variable. Selection statements are also referred to as Decision making statements. Selection statements evaluates single or multiple test expressions which results in TRUE or FALSE. The outcome of the test expression/condition helps to determine which block of statement(s) to executed if the condition is TRUE or FALSE otherwise.\n\nIn Java, we have following selection statements \n->Java If else Statements\n->Java Switch Case Statement\n\nJava Iteration Statements\nIn Java, Iteration statements are used to execute the block of code repeatedly for a specified number of times or until it meets a specified condition. Iteration statements are commonly known as loops or looping statements.\nIn Java, we have following iteration statements available-\n->Java for loop\n->Java while loop\n->Java do while loop\n\nJava Jump Statements\nJump statements are used to alter or transfer the control to other section or statements in your program from the current section.\nIn Java, we have following types of jump statements \n\n->Java Break Statement\n->Java Continue Statement\n->All of the above jump statements cause different types of jumps.");
               setContent("                                    5.Statement and flow Control\n\n");
               jTabbedPane1.setSelectedIndex(2);
    }//GEN-LAST:event_j5ActionPerformed

    private void j6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j6ActionPerformed
             jTextPane1.setText("Java - What is OOP?\nOOP stands for Object-Oriented Programming.\n\nProcedural programming is about writing procedures or methods that perform operations on the data, while object-oriented programming is about creating objects that contain both data and methods.\n\nObject-oriented programming has several advantages over procedural programming:\n\n- OOP is faster and easier to execute\n- OOP provides a clear structure for the programs\n- OOP helps to keep the Java code DRY \"Don't Repeat Yourself\", and makes the code easier to maintain, modify and debug\n- OOP makes it possible to create full reusable applications with less code and shorter development time\n -:- Tip: The \"Don't Repeat Yourself\" (DRY) principle is about reducing the repetition of code. You should extract out the codes that are common for the application, and place them at a single place and reuse them instead of repeating it.\n \n\nJava - What are Classes and Objects?\nClasses and objects are the two main aspects of object-oriented programming.\nSo, a class is a template for objects, and an object is an instance of a class.\n\nWhen the individual objects are created, they inherit all the variables and methods from the class.\n\nOOPs (Object-Oriented Programming System)\nObject means a real-world entity such as a pen, chair, table, computer, watch, etc. Object-Oriented Programming is a methodology or paradigm to design a program using classes and objects. It simplifies software development and maintenance by providing some concepts:\n\n->Object\n->Class\n->Inheritance\n->Polymorphism\n->Abstraction\n->Encapsulation\nApart from these concepts, there are some other terms which are used in Object-Oriented design:\n\n->Coupling\n->Cohesion\n->Association\n->Aggregation\n->Composition\n\n\n\nObject\n\nJava Object\nAny entity that has state and behavior is known as an object. For example, a chair, pen, table, keyboard, bike, etc. It can be physical or logical.\n\nAn Object can be defined as an instance of a class. An object contains an address and takes up some space in memory. Objects can communicate without knowing the details of each other's data or code. The only necessary thing is the type of message accepted and the type of response returned by the objects.\n\nExample: A dog is an object because it has states like color, name, breed, etc. as well as behaviors like wagging the tail, barking, eating, etc.\n\nClass\nCollection of objects is called class. It is a logical entity.\n\nA class can also be defined as a blueprint from which you can create an individual object. Class doesn't consume any space.\n\nInheritance\nWhen one object acquires all the properties and behaviors of a parent object, it is known as inheritance. It provides code reusability. It is used to achieve runtime polymorphism.\n\nPolymorphism in Java\nPolymorphism\nIf one task is performed in different ways, it is known as polymorphism. For example: to convince the customer differently, to draw something, for example, shape, triangle, rectangle, etc.\n\nIn Java, we use method overloading and method overriding to achieve polymorphism.\n\nAnother example can be to speak something; for example, a cat speaks meow, dog barks woof, etc.\n\n\n\nAbstraction :- Hiding internal details and showing functionality is known as abstraction. For example phone call, we don't know the internal processing.\n\nIn Java, we use abstract class and interface to achieve abstraction.\n\nEncapsulation in Java OOPs Concepts\nEncapsulation\nBinding (or wrapping) code and data together into a single unit are known as encapsulation. For example, a capsule, it is wrapped with different medicines.\n\nA java class is the example of encapsulation. Java bean is the fully encapsulated class because all the data members are private here.\n\nCoupling :- Coupling refers to the knowledge or information or dependency of another class. It arises when classes are aware of each other. If a class has the details information of another class, there is strong coupling. In Java, we use private, protected, and public modifiers to display the visibility level of a class, method, and field. You can use interfaces for the weaker coupling because there is no concrete implementation.\n\n\nCohesion :- Cohesion refers to the level of a component which performs a single well-defined task. A single well-defined task is done by a highly cohesive method. The weakly cohesive method will split the task into separate parts. The java.io package is a highly cohesive package because it has I/O related classes and interface. However, the java.util package is a weakly cohesive package because it has unrelated classes and interfaces.\n\n\nAssociation :- Association represents the relationship between the objects. Here, one object can be associated with one object or many objects. There can be four types of association between the objects:\n\n->One to One\n->One to Many\n->Many to One, and\n->Many to Many\nLet's understand the relationship with real-time examples. For example, One country can have one prime minister (one to one), and a prime minister can have many ministers (one to many). Also, many MP's can have one prime minister (many to one), and many ministers can have many departments (many to many).\n\nAssociation can be undirectional or bidirectional.\n\nAggregation :- Aggregation is a way to achieve Association. Aggregation represents the relationship where one object contains other objects as a part of its state. It represents the weak relationship between objects. It is also termed as a has-a relationship in Java. Like, inheritance represents the is-a relationship. It is another way to reuse objects.\n\nComposition :- The composition is also a way to achieve Association. The composition represents the relationship where one object contains other objects as a part of its state. There is a strong relationship between the containing object and the dependent object. It is the state where containing objects do not have an independent existence. If you delete the parent object, all the child objects will be deleted automatically.\n\n\nAdvantage of OOPs over Procedure-oriented programming language\n\n1) OOPs makes development and maintenance easier, whereas, in a procedure-oriented programming language, it is not easy to manage if code grows as project size increases.\n\n2) OOPs provides data hiding, whereas, in a procedure-oriented programming language, global data can be accessed from anywhere.\n\n3) OOPs provides the ability to simulate real-world event much more effectively. We can provide the solution of real word problem if we are using the Object-Oriented Programming language.\n\nWhat is the difference between an object-oriented programming language and object-based programming language?\nObject-based programming language follows all the features of OOPs except Inheritance. JavaScript and VBScript are examples of object-based programming languages.\n\n");
             setContent("                                    6.Object Oriented Programming\n\n");
             jTabbedPane1.setSelectedIndex(2);
    }//GEN-LAST:event_j6ActionPerformed

    private void j7ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j7ActionPerformed

             jTextPane1.setText("Package :- A java package is a group of similar types of classes, interfaces and sub-packages.\nPackage in java can be categorized in two form, built-in package and user-defined package.\n\nThere are many built-in packages such as java, lang, awt, javax, swing, net, io, util, sql etc.\nHere, we will have the detailed learning of creating and using user-defined packages.\n\nAdvantage of Java Package\n1) Java package is used to categorize the classes and interfaces so that they can be easily maintained.\n\n2) Java package provides access protection.\n\n3) Java package removes naming collision.\n\npackage in java\nSimple example of java package\nThe package keyword is used to create a package in java.\nHow to compile java package\nIf you are not using any IDE, you need to follow the syntax given below:\n\njavac -d directory javafilename  \nFor example\n\njavac -d . Simple.java  \nThe -d switch specifies the destination where to put the generated class file. You can use any directory name like /home (in case of Linux), d:/abc (in case of windows) etc. If you want to keep the package within the same directory, you can use . (dot).\n\nHow to run java package program\nYou need to use fully qualified name e.g. mypack.Simple etc to run the class.\n\nTo Compile: javac -d . Simple.java\nTo Run: java mypack.Simple\nOutput:Welcome to package\nThe -d is a switch that tells the compiler where to put the class file i.e. it represents destination. The . represents the current folder.\n\nHow to access package from another package?\nThere are three ways to access the package from outside the package.\n\nADVERTISEMENT\n\n\nimport package.*;\nimport package.classname;\nfully qualified name.\n1) Using packagename.*\nIf you use package.* then all the classes and interfaces of this package will be accessible but not subpackages.\n\nThe import keyword is used to make the classes and interface of another package accessible to the current package.\n\nExample of package that import the packagename.*\n\n//save by A.java  \npackage pack;  \npublic class A{  \n  public void msg(){System.out.println(\"Hello\");}  \n}  \n\n//save by B.java  \npackage mypack;  \nimport pack.*;  \n  \nclass B{  \n  public static void main(String args[]){  \n   A obj = new A();  \n   obj.msg();  \n  }  \n}  \n\nOutput:Hello\n\n\n2) Using packagename.classname\nIf you import package.classname then only declared class of this package will be accessible.\n\nExample of package by import package.classname\n//save by A.java  \n  \npackage pack;  \npublic class A{  \n  public void msg(){System.out.println(\"Hello\");}  \n}  \n//save by B.java  \npackage mypack;  \nimport pack.A;  \n  \nclass B{  \n  public static void main(String args[]){  \n   A obj = new A();  \n   obj.msg();  \n  }  \n}  \n\nOutput:Hello\n\n\n3) Using fully qualified name\nIf you use fully qualified name then only declared class of this package will be accessible. Now there is no need to import. But you need to use fully qualified name every time when you are accessing the class or interface.\nIt is generally used when two packages have same class name e.g. java.util and java.sql packages contain Date class.\n\nExample of package by import fully qualified name\n//save by A.java  \npackage pack;  \npublic class A{  \n  public void msg(){System.out.println(\"Hello\");}  \n}  \n//save by B.java  \npackage mypack;  \nclass B{  \n  public static void main(String args[]){  \n   pack.A obj = new pack.A();//using fully qualified name  \n   obj.msg();  \n  }  \n}  \n\nOutput:Hello\n\nNote: If you import a package, subpackages will not be imported.\nIf you import a package, all the classes and interface of that package will be imported excluding the classes and interfaces of the subpackages. Hence, you need to import the subpackage as well.\n\nNote: Sequence of the program must be package then import then class.\nsequence of package\nSubpackage in java\nPackage inside the package is called the subpackage. It should be created to categorize the package further.\n\nLet's take an example, Sun Microsystem has definded a package named java that contains many classes like System, String, Reader, Writer, Socket etc. These classes represent a particular group e.g. Reader and Writer classes are for Input/Output operation, Socket and ServerSocket classes are for networking etc and so on. So, Sun has subcategorized the java package into subpackages such as lang, net, io etc. and put the Input/Output related classes in io package, Server and ServerSocket classes in net packages and so on.\n\nThe standard of defining package is domain.company.package e.g. com.javatpoint.bean or org.sssit.dao.\nExample of Subpackage\npackage com.javatpoint.core;  \n\nclass Simple{  \n  public static void main(String args[]){  \n   System.out.println(\"Hello subpackage\");  \n  }  \n}  \n\nTo Compile: javac -d . Simple.java\nTo Run: java com.javatpoint.core.Simple\n\nOutput:Hello subpackage\n\nHow to send the class file to another directory or drive?\nThere is a scenario, I want to put the class file of A.java source file in classes folder of c: drive. For example:\n\nhow to put class file in another package\n//save as Simple.java  \npackage mypack;  \npublic class Simple{  \n public static void main(String args[]){  \n    System.out.println(\"Welcome to package\");  \n   }  \n}  \n\n\nTo Compile :-  e:\\sources> javac -d c:\\classes Simple.java\nTo Run :-  To run this program from e:\\source directory, you need to set classpath of the directory where the class file resides.\ne:\\sources> set classpath=c:\\classes;.;\ne:\\sources> java mypack.Simple\nAnother way to run this program by -classpath switch of java:\nThe -classpath switch can be used with javac and java tool.\n\nTo run this program from e:\\source directory, you can use -classpath switch of java that tells where to look for class file. For example:\n\ne:\\sources> java -classpath c:\\classes mypack.Simple\n\nOutput:Welcome to package\n\nWays to load the class files or jar files\nThere are two ways to load the class files temporary and permanent.\nTemporary\nBy setting the classpath in the command prompt\nBy -classpath switch\nPermanent\nBy setting the classpath in the environment variables\nBy creating the jar file, that contains all the class files, and copying the jar file in the jre/lib/ext folder.\nRule: There can be only one public class in a java source file and it must be saved by the public class name.\n\n//save as C.java otherwise Compilte Time Error  \n  \nclass A{}  \nclass B{}  \npublic class C{}  \n\n\nHow to put two public classes in a package?\nIf you want to put two public classes in a package, have two java source files containing one public class, but keep the package name same. For example:\n\n//save as A.java  \n  \npackage javatpoint;  \npublic class A{}  \n//save as B.java  \n  \npackage javatpoint;  \npublic class B{}  \n\n");
             setContent("                                    7.Packaging\n\n");
             jTabbedPane1.setSelectedIndex(2);
    }//GEN-LAST:event_j7ActionPerformed

    private void j8ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j8ActionPerformed
        jTextPane1.setText("JavaDoc :- JavaDoc tool is a document generator tool in Java programming language for generating standard documentation in HTML format. It generates API documentation. It parses the declarations ad documentation in a set of source file describing classes, methods, constructors, and fields.\n\nBefore using JavaDoc tool, you must include JavaDoc comments /**..*/ providing information about classes, methods, and constructors, etc. For creating a good and understandable document API for any java file you must write better comments for every class, method, constructor.\n\nThe JavaDoc comments is different from the normal comments because of the extra asterisk at the beginning of the comment. It may contain the HTML tags as well. \n\n// Single-Line Comment\n\n/* \n* Multiple-Line comment\n*/\n\n/** \n* JavaDoc comment\n*/\n\nBy writing a number of comments, it does not affect the performance of the Java program as all the comments are removed at compile time.\n\nJavaDoc Format:  \nIt has two parts:  a description which is followed by block tags.\nSome Integrated Development Environments (IDE) automatically generate the JavaDoc file like NetBeans, IntelliJ IDEA, Eclipse, etc.\n\nGeneration of JavaDoc:  \nTo create a JavaDoc you do not need to compile the java file. To create the Java documentation API, you need to write Javadoc followed by file name. \n\njavadoc file_name or javadoc package_name\nAfter successful execution of the above command, a number of HTML files will be created, open the file named index to see all the information about classes.\n\nJavaDoc Tags \n\n_____________________________________________________\nTag           \tParameter\t                     Description\n___________________________________________________\n@author        author_name\tDescribes an author\n@param  \tdescription\t                     provide information about method parameter or the input it takes\n@see\treference\t                     generate a link to other element of the document\n@version\tversion-name\tprovide version of the class, interface or enum.\n@return\tdescription\t                      provide the return value\n______________________________________________________________________________________\n\n\nTo generate JavaDoc in Eclipse:  \n\nSelect Generate JavaDoc option from Project menu and a wizard will appear.\nSpecify the location for the JavaDoc file on your computer, by default it will be in the C drive.\nSelect the project and then the packages for which you want to create the JavaDoc file.\nAfter this on the right side, select the classes for which you want to generate the JavaDoc, by default all the classes will be selected.\nThen you can also specify for which classes the JavaDoc will be generated by selecting the visibility.\nSelect the destination location where the generated JavaDoc will be placed.\nThen click Next or Finish. \nIf you select Next in the next window you can select the Document title and other basic options. \n\n\nExample 1:   \n____________________________________________________________________________________________\npackage exa;\n \nimport java.util.Scanner;\n \n/**\n*\n* @author Yash\n*/\npublic class Example {\n    /**\n* This is a program for adding two numbers in java.\n    * @param args\n*/\n    public static void main(String[] args)\n    {\n        /**\n        * This is the main method\n        * which is very important for\n        * execution for a java program.\n        */\n \n        int x, y;\n        Scanner sc = new Scanner(System.in);\n        /**\n        * Declared two variables x and y.\n        * And taking input from the user\n        * by using Scanner class.\n        *\n        */\n \n        x = sc.nextInt();\n        y = sc.nextInt();\n        /**\n        * Storing the result in variable sum\n        * which is of the integer type.\n        */\n        int sum = x + y;\n \n        /**\n        * Using standard output stream\n        * for giving the output.\n        * @return null\n        */\n        System.out.println(\"Sum is: \" + sum);\n    }\n}\n____________________________________________________________________________________________\n\n\nGenerating document for the above class  :-  javadoc exa");
        setContent("                                    8.JavaDoc\n\n");
        jTabbedPane1.setSelectedIndex(2); // TODO add your handling code here:
    }//GEN-LAST:event_j8ActionPerformed

    private void j9ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j9ActionPerformed
        jTextPane1.setText("Exceptions :- An exception is an unwanted or unexpected event, which occurs during the execution of a program i.e at run time, that disrupts the normal flow of the programs instructions.\n\nError vs Exception\n\nError: An Error indicates serious problem that a reasonable application should not try to catch.\nException: Exception indicates conditions that a reasonable application might try to catch.\n\n\n\nException Hierarchy\n\nAll exception and errors types are sub classes of class Throwable, which is base class of hierarchy.One branch is headed by Exception. This class is used for exceptional conditions that user programs should catch. NullPointerException is an example of such an exception.Another branch,Error are used by the Java run-time system(JVM) to indicate errors having to do with the run-time environment itself(JRE). StackOverflowError is an example of such an error.\n\nException-in-java1\n\nFor checked vs unchecked exception, see Checked vs Unchecked Exceptions\n\nHow JVM handle an Exception?\n\nDefault Exception Handling : Whenever inside a method, if an exception has occurred, the method creates an Object known as Exception Object and hands it off to the run-time system(JVM). The exception object contains name and description of the exception, and current state of the program where exception has occurred. Creating the Exception Object and handling it to the run-time system is called throwing an Exception.There might be the list of the methods that had been called to get to the method where exception was occurred. This ordered list of the methods is called Call Stack.Now the following procedure will happen.\n\nThe run-time system searches the call stack to find the method that contains block of code that can handle the occurred exception. The block of the code is called Exception handler.\nThe run-time system starts searching from the method in which exception occurred, proceeds through call stack in the reverse order in which methods were called.\nIf it finds  appropriate handler then it passes the occurred exception to it. Appropriate handler means the type of the exception object thrown matches the type of the exception object it can handle.\nIf run-time system searches all the methods on call stack and couldnt have found the appropriate handler then run-time system handover the Exception Object to default exception handler , which is part of run-time system. This handler prints the exception information in the following format and terminates program abnormally.\n\n\nException in thread \"xxx\" Name of Exception : Description\n... ...... ..  // Call Stack\nSee the below diagram to understand the flow of the call stack.\ncall stack\n\nExample :\n\n_________________________________________________________________________________________________________\n// Java program to demonstrate how exception is thrown.\nclass ThrowsExecp{\n      \n    public static void main(String args[]){\n          \n        String str = null;\n        System.out.println(str.length());\n          \n    }\n}\n__________________________________________________________________________________________________________\nOutput :\n\nException in thread \"main\" java.lang.NullPointerException\n    at ThrowsExecp.main(File.java:8)\nLet us see an example that illustrate how run-time system searches appropriate exception handling code on the call stack :\n\n______________________________________________________________________________________________________\n// Java program to demonstrate exception is thrown\n// how the runTime system searches th call stack\n// to find appropriate exception handler.\nclass ExceptionThrown\n{\n    // It throws the Exception(ArithmeticException).\n    // Appropriate Exception handler is not found within this method.\n    static int divideByZero(int a, int b){\n          \n        // this statement will cause ArithmeticException(/ by zero)\n        int i = a/b; \n          \n        return i;\n    }\n      \n    // The runTime System searches the appropriate Exception handler\n    // in this method also but couldn't have found. So looking forward\n    // on the call stack.\n    static int computeDivision(int a, int b) {\n          \n        int res =0;\n          \n        try\n        {\n          res = divideByZero(a,b);\n        }\n        // doesn't matches with ArithmeticException\n        catch(NumberFormatException ex)\n        {\n           System.out.println(\"NumberFormatException is occured\"); \n        }\n        return res;\n    }\n      \n    // In this method found appropriate Exception handler.\n    // i.e. matching catch block.\n    public static void main(String args[]){\n          \n        int a = 1;\n        int b = 0;\n          \n        try\n        {\n            int i = computeDivision(a,b);\n          \n        }\n          \n        // matching ArithmeticException\n        catch(ArithmeticException ex)\n        {\n            // getMessage will print description of exception(here / by zero)\n            System.out.println(ex.getMessage());\n        }\n    }\n}\n_____________________________________________________________________________________________________________\nOutput :\n/ by zero.\n\n\n\nHow Programmer handles an exception?\n\nCustomized Exception Handling : Java exception handling is managed via five keywords: try, catch, throw, throws, and finally. Briefly, here is how they work. Program statements that you think can raise exceptions are contained within a try block. If an exception occurs within the try block, it is thrown. Your code can catch this exception (using catch block) and handle it in some rational manner. System-generated exceptions are automatically thrown by the Java run-time system. To manually throw an exception, use the keyword throw. Any exception that is thrown out of a method must be specified as such by a throws clause. Any code that absolutely must be executed after a try block completes is put in a finally block.\n\nDetailed Article: Control flow in try catch finally block\n\nNeed of try-catch clause(Customized Exception Handling)\n\nConsider the following java program.\n\n____________________________________________________________________________________________________________________\n// java program to demonstrate \n// need of try-catch clause\n  \nclass GFG {\n    public static void main (String[] args) {\n          \n        // array of size 4.\n        int[] arr = new int[4];\n       \n        // this statement causes an exception\n        int i = arr[4];\n          \n        // the following statement will never execute\n        System.out.println(\"Hi, I want to execute\");\n    }\n}\n_____________________________________________________________________________________________________________________________\nOutput :\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 4\n    at GFG.main(GFG.java:9)\nExplanation : In the above example an array is defined with size i.e. you can access elements only from index 0 to 3. But you trying to access the elements at index 4(by mistake) thats why it is throwing an exception.In this case, JVM terminates the program abnormally. The statement System.out.println(Hi, I want to execute); will never execute. To execute it, we must handled the exception using try-catch. Hence to continue normal flow of the program, we need try-catch clause.\n\nHow to use try-catch clause\n______________________________________________________________________________________________________________________________\ntry {\n// block of code to monitor for errors\n// the code you think can raise an exception\n}\ncatch (ExceptionType1 exOb) {\n// exception handler for ExceptionType1\n}\ncatch (ExceptionType2 exOb) {\n// exception handler for ExceptionType2\n}\n// optional\nfinally {\n// block of code to be executed after try block ends\n}\n_____________________________________________________________________________________________________________________________________________________________________\n\n\nPoints to remember :\n\nIn a method, there can be more than one statements that might throw exception, So put all these statements within its own try block and provide separate exception handler within own catch block for each of them.\nIf an exception occurs within the try block, that exception is handled by the exception handler associated with it. To associate exception handler, we must put catch block after it. There can be more than one exception handlers. Each catch block is a exception handler that handles the exception of the type indicated by its argument. The argument, ExceptionType declares the type of the exception that it can handle and must be the name of the class that inherits from Throwable class.\nFor each try block there can be zero or more catch blocks, but only one finally block.\nThe finally block is optional.It always gets executed whether an exception occurred in try block or not . If exception occurs, then it will be executed after try and catch blocks. And if exception does not occur then it will be executed after the try block. The finally block in java is used to put important codes such as clean up code e.g. closing the file or closing the connection.\n\n");
         setContent("                                    9.Exception Handling\n\n");
        jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j9ActionPerformed

    private void j10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j10ActionPerformed
        jTextPane1.setText("Java brings various Streams with its I/O package that helps the user to perform all the input-output operations. These streams support all the types of objects, data-types, characters, files etc to fully execute the I/O operations.\n\n\n\nBefore exploring various input and output streams lets look at 3 standard or default streams that Java has to provide which are also most common in use:\n\n\n\nSystem.in: This is the standard input stream that is used to read characters from the keyboard or any other standard input device.\nSystem.out: This is the standard output stream that is used to produce the result of a program on an output device like the computer screen.\nHere is a list of the various print functions that we use to output statements:\n\n\n\n\nprint(): This method in Java is used to display a text on the console. This text is passed as the parameter to this method in the form of String. This method prints the text on the console and the cursor remains at the end of the text at the console. The next printing takes place from just here.\nSyntax:\nSystem.out.print(parameter);\n\n\nExample:\n\n// Java code to illustrate print()\nimport java.io.*;\n  \nclass Demo_print {\n    public static void main(String[] args)\n    {\n  \n        // using print()\n        // all are printed in the\n        // same line\n        System.out.print(\"GfG! \");\n        System.out.print(\"GfG! \");\n        System.out.print(\"GfG! \");\n    }\n}\n\nOutput:\nGfG! GfG! GfG! \nprintln(): This method in Java is also used to display a text on the console. It prints the text on the console and the cursor moves to the start of the next line at the console. The next printing takes place from the next line.\nSyntax:\nSystem.out.println(parameter);\n\nExample:\n// Java code to illustrate println()\n  \nimport java.io.*;\n  \nclass Demo_print {\n    public static void main(String[] args)\n    {\n  \n        // using println()\n        // all are printed in the\n        // different line\n        System.out.println(\"GfG! \");\n        System.out.println(\"GfG! \");\n        System.out.println(\"GfG! \");\n    }\n}\nOutput:\nGfG! \nGfG! \nGfG! \nprintf(): This is the easiest of all methods as this is similar to printf in C. Note that System.out.print() and System.out.println() take a single argument, but printf() may take multiple arguments. This is used to format the output in Java.\n\n\nExample:\n\n// A Java program to demonstrate working of printf() in Java\nclass JavaFormatter1 {\n    public static void main(String args[])\n    {\n        int x = 100;\n        System.out.printf(\n            \"Printing simple\"\n                + \" integer: x = %d\\n\",\n            x);\n  \n        // this will print it upto\n        // 2 decimal places\n        System.out.printf(\n            \"Formatted with\"\n                + \" precison: PI = %.2f\\n\",\n            Math.PI);\n  \n        float n = 5.2f;\n  \n        // automatically appends zero\n        // to the rightmost part of decimal\n        System.out.printf(\n            \"Formatted to \"\n                + \"specific width: n = %.4f\\n\",\n            n);\n  \n        n = 2324435.3f;\n  \n        // here number is formatted from\n        // right margin and occupies a\n        // width of 20 characters\n        System.out.printf(\n            \"Formatted to \"\n                + \"right margin: n = %20.4f\\n\",\n            n);\n    }\n}\n\nOutput:\n\nPrinting simple integer: x = 100\nFormatted with precison: PI = 3.14\nFormatted to specific width: n = 5.2000\nFormatted to right margin: n =         2324435.2500\nSystem.err: This is the standard error stream that is used to output all the error data that a program might throw, on a computer screen or any standard output device.\nThis stream also uses all the 3 above-mentioned functions to output the error data:\n\nprint()\nprintln()\nprintf()\n\n\nExample:\n\n// Java code to illustrate standard\n// input output streams\n  \nimport java.io.*;\npublic class SimpleIO {\n  \n    public static void main(String args[])\n        throws IOException\n    {\n  \n        // InputStreamReader class to read input\n        InputStreamReader inp = null;\n  \n        // Storing the input in inp\n        inp = new InputStreamReader(System.in);\n  \n        System.out.println(\"Enter characters, \"\n                           + \" and '0' to quit.\");\n        char c;\n        do {\n            c = (char)inp.read();\n            System.out.println(c);\n        } while (c != '0');\n    }\n}\n\nInput:\nGeeksforGeeks0\n\nOutput:\nEnter characters, and '0' to quit.\nG\ne\ne\nk\ns\nf\no\nr\nG\ne\ne\nk\ns\n0\n\n\nTypes of Streams :-\n-> Depending on the type of operations, streams can be divided into two primary classes:\n\n              ->Input Stream: These streams are used to read data that must be taken as an input from a source array or file or any peripheral device. For eg., FileInputStream, BufferedInputStream, ByteArrayInputStream etc.\n\n             ->Output Stream: These streams are used to write data as outputs into an array or file or any output peripheral device. For eg., FileOutputStream, BufferedOutputStream, ByteArrayOutputStream etc.\n\n->Depending on the types of file, Streams can be divided into two primary classes which can be further divided into other classes as can be seen through the diagram below followed by the explanations.\n\n             ->ByteStream: This is used to process data byte by byte (8 bits). Though it has many classes, the FileInputStream and the FileOutputStream are the most popular ones. The FileInputStream is used to read from the source and FileOutputStream is used to write to the destination. Here is the list of various ByteStream Classes:\n________________________________________________________________________\nStream class  \tDescription\n__________________________________________________________________________\nBufferedInputStream\tIt is used for Buffered Input Stream.\nDataInputStream\tIt contains method for reading java standard datatypes.\nFileInputStream\tThis is used to reads from a file\nInputStream\t                     This is an abstract class that describes stream input.\nPrintStream\t                      This contains the most used print() and println() method\nBufferedOutputStream\tThis is used for Buffered Output Stream.\nDataOutputStream\tThis contains method for writing java standard data types.\nFileOutputStream\tThis is used to write to a file.\nOutputStream\tThis is an abstract class that describe stream output.\n__________________________________________________________________________\n\nExample:\n\n// Java Program illustrating the\n// Byte Stream to copy\n// contents of one file to another file.\nimport java.io.*;\npublic class BStream {\n    public static void main(\n        String[] args) throws IOException\n    {\n  \n        FileInputStream sourceStream = null;\n        FileOutputStream targetStream = null;\n  \n        try {\n            sourceStream\n                = new FileInputStream(\"sorcefile.txt\");\n            targetStream\n                = new FileOutputStream(\"targetfile.txt\");\n  \n            // Reading source file and writing\n            // content to target file byte by byte\n            int temp;\n            while ((\n                       temp = sourceStream.read())\n                   != -1)\n                targetStream.write((byte)temp);\n        }\n        finally {\n            if (sourceStream != null)\n                sourceStream.close();\n            if (targetStream != null)\n                targetStream.close();\n        }\n    }\n}\n\n\nOutput:\n\nShows contents of file test.txt \nCharacterStream: In Java, characters are stored using Unicode conventions (Refer this for details). Character stream automatically allows us to read/write data character by character. Though it has many classes, the FileReader and the FileWriter are the most popular ones. FileReader and FileWriter are character streams used to read from the source and write to the destination respectively. Here is the list of various CharacterStream Classes:\n_________________________________________________________________________\nStream class\t                               Description\n__________________________________________________________________________\nBufferedReader\t         It is used to handle buffered input stream.\nFileReader\t                             This is an input stream that reads from file.\nInputStreamReader\t        This input stream is used to translate byte to character.\nOutputStreamReader\t        This output stream is used to translate character to byte.\nReader\t                              This is an abstract class that define character stream input.\nPrintWriter\t                              This contains the most used print() and println() method\nWriter\t                              This is an abstract class that define character stream output.\nBufferedWriter\t         This is used to handle buffered output stream.\nFileWriter\t                              This is used to output stream that writes to file.\n_________________________________________________________________________________\n\n\nExample:\n\n// Java Program illustrating that\n// we can read a file in a human-readable\n// format using FileReader\n  \n// Accessing FileReader, FileWriter,\n// and IOException\nimport java.io.*;\npublic class GfG {\n    public static void main(\n        String[] args) throws IOException\n    {\n        FileReader sourceStream = null;\n        try {\n            sourceStream\n                = new FileReader(\"test.txt\");\n  \n            // Reading sourcefile and\n            // writing content to target file\n            // character by character.\n            int temp;\n            while ((\n                       temp = sourceStream.read())\n                   != -1)\n                System.out.println((char)temp);\n        }\n        finally {\n            // Closing stream as no longer in use\n            if (sourceStream != null)\n                sourceStream.close();\n        }\n    }\n}\n");
         setContent("                                    10.Input Output\n\n");
        jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here: // TODO add your handling code here:
    }//GEN-LAST:event_j10ActionPerformed

    private void j11ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j11ActionPerformed
             
           setContent("                                    11.Threading\n\n");
        jTabbedPane1.setSelectedIndex(2);jTextPane1.setText("Multithreading in Java :-  Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.\nThreads can be created by using two mechanisms : \n\nExtending the Thread class \nImplementing the Runnable Interface\nThread creation by extending the Thread class\nWe create a class that extends the java.lang.Thread class. This class overrides the run() method available in the Thread class. A thread begins its life inside run() method. We create an object of our new class and call start() method to start the execution of a thread. Start() invokes the run() method on the Thread object.\n\n\n// Java code for thread creation by extending\n// the Thread class\nclass MultithreadingDemo extends Thread {\n    public void run()\n    {\n        try {\n            // Displaying the thread that is running\n            System.out.println(\n                \"Thread \" + Thread.currentThread().getId()\n                + \" is running\");\n        }\n        catch (Exception e) {\n            // Throwing an exception\n            System.out.println(\"Exception is caught\");\n        }\n    }\n}\n \n// Main Class\npublic class Multithread {\n    public static void main(String[] args)\n    {\n        int n = 8; // Number of threads\n        for (int i = 0; i < n; i++) {\n            MultithreadingDemo object\n                = new MultithreadingDemo();\n            object.start();\n        }\n    }\n}\nOutput\nThread 15 is running\nThread 14 is running\nThread 16 is running\nThread 12 is running\nThread 11 is running\nThread 13 is running\nThread 18 is running\nThread 17 is running\nThread creation by implementing the Runnable Interface\nWe create a new class which implements java.lang.Runnable interface and override run() method. Then we instantiate a Thread object and call start() method on this object. \n \n\n\n\n\n\n// Java code for thread creation by implementing\n// the Runnable Interface\nclass MultithreadingDemo implements Runnable {\n    public void run()\n    {\n        try {\n            // Displaying the thread that is running\n            System.out.println(\n                \"Thread \" + Thread.currentThread().getId()\n                + \" is running\");\n        }\n        catch (Exception e) {\n            // Throwing an exception\n            System.out.println(\"Exception is caught\");\n        }\n    }\n}\n \n// Main Class\nclass Multithread {\n    public static void main(String[] args)\n    {\n        int n = 8; // Number of threads\n        for (int i = 0; i < n; i++) {\n            Thread object\n                = new Thread(new MultithreadingDemo());\n            object.start();\n        }\n    }\n}\n\nOutput\nThread 13 is running\nThread 11 is running\nThread 12 is running\nThread 15 is running\nThread 14 is running\nThread 18 is running\nThread 17 is running\nThread 16 is running\nThread Class vs Runnable Interface \n\nIf we extend the Thread class, our class cannot extend any other class because Java doesnt support multiple inheritance. But, if we implement the Runnable interface, our class can still extend other base classes.\nWe can achieve basic functionality of a thread by extending Thread class because it provides some inbuilt methods like yield(), interrupt() etc. that are not available in Runnable interface.\nUsing runnable will give you an object that can be shared amongst multiple threads. ");
 // TODO add your handling code here:
    }//GEN-LAST:event_j11ActionPerformed

    private void GetStarted1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GetStarted1ActionPerformed
         jTextPane1.setText("1.1. The Interactive Interpreter\nThe Python installation includes an interactive interpreter that you can use to execute code as you type it. This is a great tool to use to try small samples and see the result immediately without having to manage output or print statements.\n\n1.2. Lab\nIf you have not done it yet, download the lab files at the following URL: https://thenewcircle.com/static/student-files/python_fundamentals_labs.zip\n\n(Linux / Mac) Open a terminal and type python. (Windows) Open the Python IDLE IDE from the Start menu.\n\nWhat is the version number?\nType help(str) This is a simple way to get documentation for a builtin or standard library function. You can also use the online HTML documentation.\n>>> help(str)\nHelp on class str in module __builtin__:\n\nclass str(basestring)\n |  str(object) -> string\n |\n |  Return a nice string representation of the object.\n |  If the argument is a string, the return value is the same object.\n |\n |  Method resolution order:\n |      str\n |      basestring\n |      object\n |\n |  Methods defined here:\n |\n |  __add__(...)\n |      x.__add__(y) <==> x+y\n |\n ...\nNote the use of methods with names with two underscores at the beginning and end of the name. These are methods that you will generally never call directly. How do you think the __add__() method gets executed?\nNow try typing the following commands to see the output. Note that you dont assign a result, you get that result in the interpreter.\n>>> 'hello world'\n'hello world'\n>>> _ + '!'\n'hello world!'\n>>> hw = _\n>>> hw\n'hello world!'\n\n\nTip :- In the interactive interpreter, you can use the special variable \"_\" to refer to the result of the last statement. Handy in this mode, but meaningless in scripts.\n\nNote :- Throughout the rest of this courseware, the \">>>\" in a listing indicates that the code is being executed in the interactive interpreter.\n\n1.3. Lab\nEnter the following into a new file \"hello.py\" in your text editor of choice.\n\nprint 'hello world!'\nSave and exit, then execute the script as shown below.\n\n$ python hello.py\nhello world\n\nTip :- On unix, you can also use shebang (#!) notation on the first line.\n\n");
         setContent("                                    1. Getting Started\n\n");
             jTabbedPane1.setSelectedIndex(2); 
    }//GEN-LAST:event_GetStarted1ActionPerformed

    private void j12ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j12ActionPerformed
        jTextPane1.setText("1.1. The Interactive Interpreter\nThe Python installation includes an interactive interpreter that you can use to execute code as you type it. This is a great tool to use to try small samples and see the result immediately without having to manage output or print statements.\n\n1.2. Lab\nIf you have not done it yet, download the lab files at the following URL: https://thenewcircle.com/static/student-files/python_fundamentals_labs.zip\n\n(Linux / Mac) Open a terminal and type python. (Windows) Open the Python IDLE IDE from the Start menu.\n\nWhat is the version number?\nType help(str) This is a simple way to get documentation for a builtin or standard library function. You can also use the online HTML documentation.\n>>> help(str)\nHelp on class str in module __builtin__:\n\nclass str(basestring)\n |  str(object) -> string\n |\n |  Return a nice string representation of the object.\n |  If the argument is a string, the return value is the same object.\n |\n |  Method resolution order:\n |      str\n |      basestring\n |      object\n |\n |  Methods defined here:\n |\n |  __add__(...)\n |      x.__add__(y) <==> x+y\n |\n ...\nNote the use of methods with names with two underscores at the beginning and end of the name. These are methods that you will generally never call directly. How do you think the __add__() method gets executed?\nNow try typing the following commands to see the output. Note that you dont assign a result, you get that result in the interpreter.\n>>> 'hello world'\n'hello world'\n>>> _ + '!'\n'hello world!'\n>>> hw = _\n>>> hw\n'hello world!'\n\n\nTip :- In the interactive interpreter, you can use the special variable \"_\" to refer to the result of the last statement. Handy in this mode, but meaningless in scripts.\n\nNote :- Throughout the rest of this courseware, the \">>>\" in a listing indicates that the code is being executed in the interactive interpreter.\n\n1.3. Lab\nEnter the following into a new file \"hello.py\" in your text editor of choice.\n\nprint 'hello world!'\nSave and exit, then execute the script as shown below.\n\n$ python hello.py\nhello world\n\nTip :- On unix, you can also use shebang (#!) notation on the first line.\n\n");
         setContent("                                    1. Getting Started\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j12ActionPerformed

    private void j13ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j13ActionPerformed
        jTextPane1.setText("2.1. Strings\nString literals can be defined with any of single quotes ('), double quotes (\") or triple quotes (''' or \"\"\"). All give the same result with two important differences.\n\nIf you quote with single quotes, you do not have to escape double quotes and vice-versa.\nIf you quote with triple quotes, your string can span multiple lines.\n>>> 'hello' + \" \" + '''world'''\n'hello world'\n2.2. Integers\nInteger literals are created by any number without a decimal or complex component.\n\n>>> 1 + 2\n3\n2.2.1. Integer Division\nSome programming tasks make extensive use of integer division and Python behaves in the expected manner.\n\n>>> 10 / 3\n3\n>>> 10 % 3\n1\n>>> divmod(10, 3)\n(3, 1)\n2.3. Floats\nFloat literals can be created by adding a decimal component to a number.\n\n>>> 1.0 / .99\n1.0101010101010102\n2.4. Complex\nComplex literals can be created by using the notation x + yj where x is the real component and y is the imaginary component.\n\n>>> 1j * 1j\n(-1+0j)\n");
        setContent("                                    2. Types\n\n");
             jTabbedPane1.setSelectedIndex(2); // TODO add your handling code here:
    }//GEN-LAST:event_j13ActionPerformed

    private void j14ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j14ActionPerformed
        jTextPane1.setText("3.1. Definining\nA variable in Python is defined through assignment. There is no concept of declaring a variable outside of that assignment.\n\n>>> ten = 10\n>>> ten\n10\n3.2. Dynamic Typing\nIn Python, while the value that a variable points to has a type, the variable itself has no strict type in its definition. You can re-use the same variable to point to an object of a different type. It may be helpful to think of variables as \"labels\" associated with objects.\n\n>>> ten = 10\n>>> ten\n10\n>>> ten = 'ten'\n>>> ten\n'ten'\n3.3. Strong Typing\n[Caution]\tCaution\nWhile Python allows you to be very flexible with your types, you must still be aware of what those types are. Certain operations will require certain types as arguments.\n\n>>> 'Day ' + 1\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  TypeError: cannot concatenate 'str' and 'int' objects\nThis behavior is different from some other loosely-typed languages. If you were to do the same thing in JavaScript, you would get a different result.\n\nd8> 'Day ' + 1\nDay 1\nIn Python, however, it is possible to change the type of an object through builtin functions.\n\n>>> 'Day ' + str(1)\n'Day 1'\nThis type conversion can be a necessity to get the outcome that you want. For example, to force float division instead of integer division. Without an explicit conversion, the division of two integers will result in a third integer.\n\n>>> 10 / 3\n3\nBy converting one of the operands to a float, Python will perform float division and give you the result you were looking for (at least within floating point precision).\n\n>>> float(10) / 3\n3.3333333333333335\n>>> 10 / float(3)\n3.3333333333333335\nYou can also force the initial value to be a float by including a decimal point.\n\n>>> 10.0 / 3\n3.3333333333333335\nMake sure to account for order of operations, though. If you convert the result of integer division, it will be too late to get the precision back.\n\n>>> float(10 / 3)\n3.0\n3.4. Internals\nEach object in Python has three key attributes: a type, a value, and an id. The type and the id can be examined using the type() and id() functions respectively. The id is implementation-dependent, but in most standard Python interpreters represents the location in memory of the object.\n\n>>> a = 1\n>>> type(a)\n<type 'int'>\n>>> id(a)\n4298185352\n>>> b = 2\n>>> type(b)\n<type 'int'>\n>>> id(b)\n4298185328\nMultiple instances of the same immutable may be optimized by the interpreter to, in fact, be the same instance with multiple labels. The next example is a continuation of the previous. Notice that by subtracting 1 from b, its value becomes the same as a and so does its id. So rather than changing the value at the location to which b points, b itself is changed to point to a location that holds the right value. This location may be the location of an already existing object or it may be a new location. That choice is an optimization made by the interpreter.\n\n>>> b = b - 1\n>>> b\n1\n>>> id(b)\n4298185352\nPython uses reference counting to track how many of these labels are currently pointing to a particular object. When that count reaches 0, the object is marked for garbage collection after which it may be removed from memory.");
        setContent("                                    3. Variables\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j14ActionPerformed

    private void j15ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j15ActionPerformed
        jTextPane1.setText("4.1. Boolean Evaluation\nBoolean expressions are created with the keywords and, or, not and is. For example:\n\n>>> True and False\nFalse\n>>> True or False\nTrue\n>>> not True\nFalse\n>>> not False\nTrue\n>>> True is True\nTrue\n>>> True is False\nFalse\n>>> 'a' is 'a'\nTrue\nCompound boolean evaluations shortcut and return the last expression evaluated. In other words:\n\n>>> False and 'a' or 'b'\n'b'\n>>> True and 'a' or 'b'\n'a'\nUp until Python 2.6, this mechanism was the simplest way to implement a \"ternary if\" (a = expression ? if_true : if_false) statement. As of Python 2.6, it is also possible to use:\n\n>>> 'a' if True else 'b'\n'a'\n>>> 'a' if False else 'b'\n'b'\n4.2. Truthiness\nMany of the types in Python have truth values that can be used implicitly in boolean checks. However, it is important to note that this behavior is different from C where almost everything ends up actually being a zero. True, False and None in Python are all singleton objects and comparisons are best done with the is keyword.\n\nTable 1. Truthiness values\n\nValue\n\ntruthy\n\nNone\n\nTrue\n\nFalse\n\nNone\n\nN\n\nY\n\nN\n\nN\n\n0\n\nN\n\nN\n\nN\n\nN\n\n1\n\nY\n\nN\n\nN\n\nN\n\n'hi'\n\nY\n\nN\n\nN\n\nN\n\nTrue\n\nY\n\nN\n\nY\n\nN\n\nFalse\n\nN\n\nN\n\nN\n\nY\n\n[]\n\nN\n\nN\n\nN\n\nN\n\n[0]\n\nY\n\nN\n\nN\n\nN\n\n\n\n4.3. Branching (if / elif / else)\nPython provides the if statement to allow branching based on conditions. Multiple elif checks can also be performed followed by an optional else clause. The if statement can be used with any evaluation of truthiness.\n\n>>> i = 3\n>>> if i < 3:\n...     print 'less than 3'\n... elif i < 5:\n...     print 'less than 5'\n... else:\n...     print '5 or more'\n...\nless than 5\n4.4. Block Structure and Whitespace\nThe code that is executed when a specific condition is met is defined in a \"block.\" In Python, the block structure is signalled by changes in indentation. Each line of code in a certain block level must be indented equally and indented more than the surrounding scope. The standard (defined in PEP-8) is to use 4 spaces for each level of block indentation. Statements preceding blocks generally end with a colon (:).\n\nBecause there are no semi-colons or other end-of-line indicators in Python, breaking lines of code requires either a continuation character (\\ as the last char) or for the break to occur inside an unfinished structure (such as open parentheses).\n\n4.5. Lab\nEdit hello.py as follows:\n\nfrom datetime import datetime\n\nhour = datetime.now().hour\nif hour < 12:\n    time_of_day = 'morning'\nelse:\n    time_of_day = 'afternoon'\n\nprint 'Good %s, world!' % time_of_day\n4.6. Multiple Cases\nPython does not have a switch or case statement. Generally, multiple cases are handled with an if-elif-else structure and you can use as many elifs as you need.\n\n4.7. Lab\nFix hello.py to handle evening and the midnight case.");
        setContent("                                    4. Simple Expressions\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j15ActionPerformed

    private void j16ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j16ActionPerformed
        jTextPane1.setText("One of the great advantages of Python as a programming language is the ease with which it allows you to manipulate containers. Containers (or collections) are an integral part of the language and, as youll see, built in to the core of the languages syntax. As a result, thinking in a Pythonic manner means thinking about containers.\n\n5.1. Lists\nThe first container type that we will look at is the list. A list represents an ordered, mutable collection of objects. You can mix and match any type of object in a list, add to it and remove from it at will.\n\nCreating Empty Lists. To create an empty list, you can use empty square brackets or use the list() function with no arguments.\n\n>>> l = []\n>>> l\n[]\n>>> l = list()\n>>> l\n[]\nInitializing Lists. You can initialize a list with content of any sort using the same square bracket notation. The list() function also takes an iterable as a single argument and returns a shallow copy of that iterable as a new list. A list is one such iterable as well see soon, and well see others later.\n\n>>> l = ['a', 'b', 'c']\n>>> l\n['a', 'b', 'c']\n>>> l2 = list(l)\n>>> l2\n['a', 'b', 'c']\nA Python string is also a sequence of characters and can be treated as an iterable over those characters. Combined with the list() function, a new list of the characters can easily be generated.\n\n>>> list('abcdef')\n['a', 'b', 'c', 'd', 'e', 'f']\nAdding. You can append to a list very easily (add to the end) or insert at an arbitrary index.\n\n>>> l = []\n>>> l.append('b')\n>>> l.append('c')\n>>> l.insert(0, 'a')\n>>> l\n['a', 'b', 'c']\n[Note]\tNote\nWhile inserting at position 0 will work, the underlying structure of a list is not optimized for this behavior. If you need to do it a lot, use collections.deque, which is optimized for this behavior (at the expense of some pointer overhead) and has an appendleft() function.\n\nIterating. Iterating over a list is very simple. All iterables in Python allow access to elements using the for ... in statement. In this structure, each element in the iterable is sequentially assigned to the \"loop variable\" for a single pass of the loop, during which the enclosed block is executed.\n\n>>> for letter in l:\n...     print letter,\n...\na b c\n[Note]\tNote\nThe print statement adds a newline character when called. Using a trailing \",\" in the print statement prevents a newline character from being automatically appended.\n\nIterating with while. It is also possible to use a while loop for this iteration. A while loop is most commonly used to perform an iteration of unknown length, either checking a condition on each entry or using a break statement to exit when a condition is met.\n\nFor the simplicity of the example, here we will use the list.pop() method to consume the list entries from the right.\n\n>>> l = ['a', 'b', 'c']\n>>> while len(l):\n...     print l.pop(),\n...\nc b a\nIterating with an Index. In some instances, you will actually want to know the index of the item that you are accessing inside the for loop. You can handle this in a traditional form using the builtin len() and range() functions.\n\n>>> len(l)\n3\n>>> range(3)\n[0, 1, 2]\n\n>>> for i in range(len(l)):\n...     print i, l[i]\n...\n0 a\n1 b\n2 c\nHowever, with a little more foundation, we will see a better way.\n\nAccess and Slicing. Accessing individual items in a list is very similar to accessing the elements of an array in many languages, often referred to as subscripting, or more accurately, using the subscript operator. One less common, but very useful addition, is the ability to use negative indexing, where alist[-1] returns the last element of alist. Note that 0 represents the first item in a list while -1 represents the last.\n\nSlices are another extension of this subscripting syntax providing access to subsets of the list. The slice is marked with one or two colons (:) within the square bracket subscript.\n\nIn the single colon form, the first argument represents the starting index (inclusive) and the second argument represents the end index (exclusive). If the first is omitted (e.g. l[:2]), the start index is the beginning of the list. If the second argument is omitted (e.g. l[2:]) the end index is the last item in the list.\n\nIn the double colon form, the first two arguments are unchanged and the third represents stride. For example, l[::2] would take every second item from a list.\n\n>>> l = list('abcdefgh')\n>>> l\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n>>> l[3]\n'd'\n>>> l[-3]\n'f'\n\n>>> l[1:4]\n['b', 'c', 'd']\n\n>>> l[1:-1]\n['b', 'c', 'd', 'e', 'f', 'g']\n\n>>> l[1:-1:2]\n['b', 'd', 'f']\nPresence and Finding. Checking for the presence of an object in a list is performed with the in keyword. The index() method of a list returns the actual location of the object.\n\n>>> chars = list('abcdef')\n>>> chars\n['a', 'b', 'c', 'd', 'e', 'f']\n>>> 'g' in chars\nFalse\n>>> 'c' in chars\nTrue\n>>> chars.index('c')\n2\n5.2. Lab\nCreate a new file class.py\nUse a list to store the first names of everyone in the class.\nUse a for loop to print Hello <name> to stdout for everyone.\n5.3. Strings Revisited\nPythons string object not only acts as a sequence but has many useful methods for moving back and forth to other types of sequences. A very common use case in data processing is splitting strings into substrings based on a delimiter. This is done with the split() method, which returns a list of the components.\n\n>>> s = 'abc.def'\n\n>>> parts = s.split('.')\n>>> parts\n['abc', 'def']\nThe converse method to split() is join() which joins a list together separating each element by the contents of the string on which the method was called.\n\nThis method looks backwards to many people when they first see it (thinking that .join() should be a method of the list object). It is also important to realize that a string literal in Python is just another instance of a string object.\n\nUsing '/' from the following example, that string is a string object and the .join() method can be called on it. There is no point assigning it to a variable before using it, because it is of no value after that single call.\n\n>>> new_string = '/'.join(parts)\n>>> new_string\n'abc/def'\nOther standard sequence operations also apply.\n\n>>> s = 'hello world'\n>>> len(s)\n11\n>>> s[4]\n'o'\n>>> s[2:10:2]\n'lowr'\nA less sequence-oriented, but still quite common method for dealing with strings is trimming whitespace with the strip() method and its relatives: lstrip() and rstrip().\n\n>>> s = '   abc   '\n>>> s.strip()\n'abc'\n5.4. Tuples\nA tuple is like an immutable list. It is slightly faster and smaller than a list, so it is useful. Tuples are also commonly used in core program features, so recognize them.\n\nCreating. Similar to lists, empty tuples can be created with an empty pair of parentheses, or with the tuple() builtin function.\n\n>>> t = ()\n>>> t\n()\n>>> tuple()\n()\nTuples can also be initialized with values (and generally are, since they are immutable). There is one important distinction to make due to the use of parentheses, which is that a 1-tuple (tuple with one item) requires a trailing comma to indicate that the desired result is a tuple. Otherwise, the interpreter will see the parentheses as nothing more than a grouping operation.\n\n>>> t = ('Othello')\n>>> t\n'Othello'\n>>> t = ('Othello',)\n>>> t\n('Othello',)\nThe behavior for a 2-tuple and beyond is nothing new. Note that the parentheses become optional at this point. The implication that any comma-separated list without parentheses becomes a tuple is both useful and important in Python programming.\n\n>>> t = ('Othello', 'Iago')\n>>> t\n('Othello', 'Iago')\n>>> t = 'Othello', 'Iago'\n>>> t\n('Othello', 'Iago')\nTuples can also be created by passing an iterable to the tuple() function.\n\n>>> l = ['Othello', 'Iago']\n>>> tuple(l)\n('Othello', 'Iago')\nUnpacking. A very common paradigm for accessing tuple content in Python is called unpacking. It can be used on lists as well, but since it requires knowledge of the size of the container, it is far more common with tuples.\n\nBy assigning a tuple to a list of variables that matches the count of items in the tuple, the variables are individually assigned ordered values from the tuple.\n\n>>> t = ('Othello', 'Iago')\n>>> hero, villain = t\n>>> hero\n'Othello'\n>>> villain\n'Iago'\nAn interesting and valuable side-effect of the natural use of tuples is the ability to elegantly swap variables.\n\n>>> t = ('Othello', 'Iago')\n>>> t\n('Othello', 'Iago')\n\n>>> hero, villain = t\n\n>>> hero\n'Othello'\n>>> villain\n'Iago'\n\n>>> hero, villain = villain, hero\n\n>>> hero\n'Iago'\n>>> villain\n'Othello'\nAccessing and Slicing. Tuples can be accessed and sliced in the same manner as lists. Note that tuple slices are tuples themselves.\n\n>>> t[0]\n'Othello'\n>>> t = ('Othello', 'Iago', 'Desdemona')\n>>> t[0::2]\n('Othello', 'Desdemona')\nIterating. Tuples are iterable, in exactly the same manner as lists.\n\n>>> t = ('Othello', 'Iago')\n>>> for character in t:\n...     print character\n...\nOthello\nIago\nSince a tuple is iterable, a mutable copy is easily created using the list() builtin.\n\n>>> t = ('Othello', 'Iago')\n>>> list(t)\n['Othello', 'Iago']\nIndexed List Iteration Revisited. Now that you know how to unpack tuples, you can see a better way to iterate lists with an index. The builtin enumerate() function takes a single argument (an iterable) and returns an iterator of 2-tuples. Each 2-tuple contains an index and an item from the original iterable. These 2-tuples can be unpacked into separate loop variables as part of the for statement.\n\n>>> l = ['a', 'b', 'c']\n>>> for i, letter in enumerate(l):\n...     print i, letter\n...\n0 a\n1 b\n2 c\n5.5. Lab\nUpdate classmates.py to use a tuple of 3-tuples of first, last, role.\nPrint to screen using a for loop and unpacking.\n5.6. Dictionaries\nA dictionary is an implementation of a key-value mapping that might go by the name \"hashtable\" or \"associative array\" in another language. Dictionaries are the building blocks of the Python language itself, so they are quite prevalent and also quite efficient.\n\n[Warning]\tWarning\nDictionary order is undefined and implementation-specific. It can be different across interpreters, versions, architectures, and more. Even multiple executions in the same environment.\n\nCreating. Following the analogy of the other container types, dictionaries are created using braces, i.e. {}. There is also a dict() builtin function that accepts an arbitrary set of keyword arguments.\n\n[Note]\tNote\nUnlike some similar languages, string keys in Python must always be quoted.\n\n>>> characters = {'hero': 'Othello', 'villain': 'Iago', 'friend': 'Cassio'}\n>>> characters\n{'villain': 'Iago', 'hero': 'Othello', 'friend': 'Cassio'}\n\n>>> characters = dict(hero='Othello', villain='Iago', friend='Cassio')\n>>> characters\n{'villain': 'Iago', 'hero': 'Othello', 'friend': 'Cassio'}\nAccessing. Dictionary values can be accessed using the subscript operator except you use the key instead of an index as the subscript argument. The presence of keys can also be tested with the in keyword.\n\n>>> if 'villain' in characters:\n...     print characters['villain']\n...\nIago\nAdding. A new entry can be created where there is no existing key using the same subscripting notation and assignment.\n\n>>> characters['beauty'] = 'Desdemona'\nModifying. Existing entries are modified in exactly the same manner.\n\n>>> characters['villain'] = 'Roderigo'\n\n>>> characters\n{'villain': 'Roderigo', 'hero': 'Othello', 'beauty': 'Desdemona', 'friend': 'Cassio'}\nFailed Lookups. If you use the subscript operator and the key is not found, a KeyError will be raised. If this behavior is not desired, using the get() method of the dictionary will return a supplied default value when the key is not found. If no default is provided, None is returned when the key is not found. The get() method does not alter the contents of the dictionary itself.\n\n>>> characters['horse']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  KeyError: 'horse'\n>>> characters.get('horse', 'Ed')\n'Ed'\n>>> characters\n{'villain': 'Roderigo', 'hero': 'Othello', 'friend': 'Cassio', 'beauty': 'Desdemona'}\n>>> characters.get('horse')\n>>>\nYou can also set the value in the case that it wasnt found using the setdefault() method.\n\n>>> characters\n{'villain': 'Roderigo', 'hero': 'Othello', 'friend': 'Cassio', 'beauty': 'Desdemona'}\n>>> characters.setdefault('horse', 'Ed')\n'Ed'\n>>> characters\n{'villain': 'Roderigo', 'horse': 'Ed', 'hero': 'Othello', 'friend': 'Cassio', 'beauty': 'Desdemona'}\nIterating. Because the dictionary has both keys and values, iterating has a few more options. A simple for  in statement will iterate over the keys, which is one method to access both.\n\n>>> for role in characters:\n...     print role, characters[role]\n...\nvillain Roderigo\nhero Othello\nbeauty Desdemona\nfriend Cassio\nHowever, the items() method will return 2-tuples of key, value pairs, which can be unpacked in the for loop.\n\n>>> characters.items()\n[('villain', 'Roderigo'), ('hero', 'Othello'), ('friend', 'Cassio'), ('beauty', 'Desdemona')]\n>>> for role, name in characters.items():\n...     print role, name\n...\nvillain Roderigo\nhero Othello\nfriend Cassio\nbeauty Desdemona\n[Note]\tNote\nThe .items() method returns a newly allocated list full of newly allocated tuples, that exists only for the duration of the iteration. Whenever possible, it is preferable to use the .iteritems() method, which returns a generator. This generator holds a reference to the original dictionary and produces individual 2-tuples on demand. The downside of the iterator is that it expects the state of the dictionary to remain consistent during iteration.\n\n>>> characters.iteritems()\n<dictionary-itemiterator object at 0x100473b50>\n>>> for role, name in characters.iteritems():\n...     print role, name\n...\nvillain Roderigo\nhero Othello\nfriend Cassio\nbeauty Desdemona\n5.7. Lab\nOne more time on classmates.py\nInsert the tuples into a dictionary using firstname as the key\nAsk for a firstname on the command-line and print the data\nIf its not there, prompt for last name and role\nAdd it\nPrint the new list\n5.8. Sets\nA set is a mutable, unordered, unique collection of objects. It is designed to reflect the properties and behavior of a true mathematical set. A frozenset has the same properties as a set, except that it is immutable.\n\nCreating. A new set is created using the set() builtin. This function without any parameters will return a new, empty set. It will also accept a single argument of an iterable, in which case it will return a new set containing one element for each unique element in the iterable.\n\n>>> s = set()\n>>> s\nset([])\n>>> s = set(['Beta', 'Gamma', 'Alpha', 'Delta', 'Gamma', 'Beta'])\n>>> s\nset(['Alpha', 'Beta', 'Gamma', 'Delta'])\nAccessing. Sets are not designed for indexed access, so it is not possible to use subscript notation. Like a list, we can use the .pop() method to consume elements, but note that the order will be undefined.\n\n>>> s\nset(['Alpha', 'Beta', 'Gamma', 'Delta'])\n>>> while len(s):\n...     print s.pop(),\n...\nAlpha Beta Gamma Delta\nSet Operations. Not surprisingly, the real value of sets shows itself in set operations. Sets use sensibly overloaded operators to calculate unions and intersections of sets. You can also call these methods by name.\n\n>>> s1 = set(['Beta', 'Gamma', 'Alpha', 'Delta', 'Gamma', 'Beta'])\n>>> s2 = set(['Beta', 'Alpha', 'Epsilon', 'Omega'])\n>>> s1\nset(['Alpha', 'Beta', 'Gamma', 'Delta'])\n>>> s2\nset(['Alpha', 'Beta', 'Omega', 'Epsilon'])\n\n>>> s1.union(s2)\nset(['Epsilon', 'Beta', 'Delta', 'Alpha', 'Omega', 'Gamma'])\n>>> s1 | s2\nset(['Epsilon', 'Beta', 'Delta', 'Alpha', 'Omega', 'Gamma'])\n\n>>> s1.intersection(s2)\nset(['Alpha', 'Beta'])\n>>> s1 & s2\nset(['Alpha', 'Beta'])\n\n>>> s1.difference(s2)\nset(['Gamma', 'Delta'])\n>>> s1 - s2\nset(['Gamma', 'Delta'])\n\n>>> s1.symmetric_difference(s2)\nset(['Epsilon', 'Delta', 'Omega', 'Gamma'])\n>>> s1 ^ s2\nset(['Epsilon', 'Delta', 'Omega', 'Gamma'])\n5.9. Collection Transitions\nAs you saw previously, dict.items() returns a list of 2-tuples representing key-value pairs. Inversely, a list of 2-tuples can be passed to the dict() factory function to create a dictionary using the first item from each tuple as a key and the second item as the value. zip() takes n lists and returns one list of n-tuples.\n\n>>> roles = characters.keys()\n>>> roles\n['villain', 'hero', 'beauty', 'friend']\n>>> names = characters.values()\n>>> names\n['Roderigo', 'Othello', 'Desdemona', 'Cassio']\n\n>>> tuples = zip(roles, names)\n>>> tuples\n[('villain', 'Roderigo'), ('hero', 'Othello'), ('beauty', 'Desdemona'), ('friend', 'Cassio')]\n\n>>> new_characters = dict(tuples)\n>>> new_characters\n{'villain': 'Roderigo', 'hero': 'Othello', 'friend': 'Cassio', 'beauty': 'Desdemona'}\n");
        setContent("                                    5. Advanced Types: Containers\n\n");
             jTabbedPane1.setSelectedIndex(2);/// TODO add your handling code here:
    }//GEN-LAST:event_j16ActionPerformed

    private void j17ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j17ActionPerformed
        jTextPane1.setText("6.1. Loop-Else\nAn addition to both for and while loops in Python that is not common to all languages is the availability of an else clause. The else block after a loop is executed in the case where no break occurs inside the loop.\n\nThe most common paradigm for using this clause occurs when evaluating a dataset for the occurences of a certain condition and breaking as soon as it is found. Rather than setting a flag when found and checking after to see the result, the else clause simplifies the code.\n\nIn the following example, if a multiple of 5 is found, the break exits the for loop without executing the else clause.\n\n>>> for x in range(1,5):\n...     if x % 5 == 0:\n...         print '%d is a multiple of 5' % x\n...         break\n... else:\n...     print 'No multiples of 5'\n...\nNo multiples of 5\n\n>>> for x in range(11,20):\n...     if x % 5 == 0:\n...         print '%d is a multiple of 5' % x\n...         break\n... else:\n...     print 'No multiples of 5'\n...\n15 is a multiple of 5\nWithout this feature, the code would look something like:\n\n>>> found = False\n>>> for x in range(1,5):\n...     if x % 5 == 0:\n...         print '{0} is a multiple of 5'.format(x)\n...         found = True\n...         break\n...\n>>> if not found:\n...     print 'No multiples of 5'\n...\nNo multiples of 5");
         setContent("                                    6. A Bit More Iteration\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j17ActionPerformed

    private void j18ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j18ActionPerformed
        jTextPane1.setText("7.1. Defining\nA function in Python is defined with the def keyword. Functions do not have declared return types. A function without an explicit return statement returns None. In the case of no arguments and no return value, the definition is very simple.\n\nCalling the function is performed by using the call operator () after the name of the function.\n\n>>> def hello_function():\n...     print 'Hello World, it\\'s me.  Function.'\n...\n\n>>> hello_function()\nHello World, it's me.  Function.\n7.2. Arguments\nThe arguments of a function are defined within the def statement. Like all other variables in Python, there is no explicit type associated with the function arguments. This fact is important to consider when making assumptions about the types of data that your function will receive.\n\nFunction arguments can optionally be defined with a default value. The default value will be assigned in the case that the argument is not present in the call to the function. All arguments without default values must be listed before arguments with default values in the function definition.\n\nAny argument can be passed either implicitly by position or explicitly by name, regardless of whether or not it has a default value defined.\n\n>>> def record_score(name, score=0):\n...     print '%s scored %s' % (name, score)\n...\n\n>>> record_score('Jill', 4)\nJill scored 4\n\n>>> record_score('Jack')\nJack scored 0\n\n>>> record_score(score=3, name='Pail')\nPail scored 3\n\n>>> record_score(2)\n2 scored 0\n\n>>> record_score(score=2)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  TypeError: record_score() takes at least 1 non-keyword argument (0 given)\n\n>>> record_score()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  TypeError: record_score() takes at least 1 argument (0 given)\n[Note]\tNote\nLook carefully at the example above. There is an asymmetry in the use of the = sign for defining vs. passing arguments that can be confusing to beginners. An argument with a default value can be passed using only position and an argument without a default can be passed using a keword.\n\n7.3. Mutable Arguments and Binding of Default Values\nWhen defining default arguments, take special care with mutable data types. The instance of the default value is bound at the time the function is defined. Consequently, there is a single instance of the mutable object that will be used across all calls to the function.\n\n>>> def add_items(new_items, base_items=[]):\n...     for item in new_items:\n...         base_items.append(item)\n...     return base_items\n...\n\n>>> add_items((1, 2, 3))\n[1, 2, 3]\n\n>>> add_items((1, 2, 3))\n[1, 2, 3, 1, 2, 3]\nAs a result, it is best to use default value of None as a flag to signify the absense of the argument and handle the case inside the function body.\n\n>>> def add_items(new_items, base_items=None):\n...     if base_items is None:\n...         base_items = []\n...     for item in new_items:\n...         base_items.append(item)\n...     return base_items\n...\n\n>>> add_items((1, 2, 3))\n[1, 2, 3]\n\n>>> add_items((1, 2, 3))\n[1, 2, 3]\n7.4. Accepting Variable Arguments\nIn addition to named arguments, functions can accept two special collections of arguments.\n\nThe first is a variable-length, named tuple of any additional positional arguments received by the function. This special argument is identified by prefixing it with a single asterisk (*).\n\nThe second is a variable-length dictionary containing all keyword arguments passed to the function that were not explicitly defined as part of the function arguments. This argument is identified by prefixing it with two asterisks (**).\n\nIt is not required, but conventional and therefore highly recommended, to name these two arguments args and kwargs, respectively.\n\nThe use of these two arguments is illustrated in the following set of examples.\n\n>>> def variable_function(*args, **kwargs):\n...     print 'args:', args\n...     print 'kwargs:', kwargs\n...\n\n>>> variable_function('simple')\nargs: ('simple',)\nkwargs: {}\n\n>>> variable_function(type='Complex')\nargs: ()\nkwargs: {'type': 'Complex'}\n\n>>> def mixed_function(a, b, c=None, *args, **kwargs):\n...     print '(a, b, c):', (a, b, c)\n...     print 'args:', args\n...     print 'kwargs:', kwargs\n...\n\n>>> mixed_function(1, 2, 3, 4, 5, d=10, e=20)\n(a, b, c): (1, 2, 3)\nargs: (4, 5)\nkwargs: {'e': 20, 'd': 10}\n7.5. Unpacking Argument Lists\nIt is also possible to construct argument lists (positional or keyword) and pass them into a function.\n\nFor positional arguments, insert them into a tuple / list and prepend with an asterisk (*) in the function call.\n\nFor keyword arguments, use a dictionary and prepend with two asterisks (**).\n\n>>> def printer(a, b, c=0, d=None):\n...     print 'a: {0}, b: {1}, c: {2}, d: {3}'.format(a, b, c, d)\n...\n>>> printer(2, 3, 4, 5)\na: 2, b: 3, c: 4, d: 5\n\n>>> ordered_args = (5, 6)\n>>> keyword_args = {'c': 7, 'd': 8}\n\n>>> printer(*ordered_args, **keyword_args)\na: 5, b: 6, c: 7, d: 8\n[Note]\tNote\nThe example above shows another potentially confusing asymmetry in Python. You can pass arguments using the regular style to a function defined using variable arguments, and you can pass unpacked variable argument lists to a function defined without variable arguments.\n\n7.6. Scope\nEach function evaluation creates a local namespace that is manipulated at any level within the function. As a result, variables can be initially defined at a seemingly lower level of scope than they are eventually used.\n\n>>> def deep_scope():\n...     if True:\n...         if True:\n...             if True:\n...                 x = 5\n...     return x\n...\n\n>>> deep_scope()\n5\n[Warning]\tWarning\nThis model for scope can simplify your code, but pay attention. If you dont anticipate all code paths, you can end up referencing undefined variables.\n\n>>> def oops(letter):\n...     if letter == 'a':\n...         out = 'A'\n...     return out\n...\n\n>>> oops('a')\n'A'\n\n>>> oops('b')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"<stdin>\", line 4, in oops\nUnboundLocalError: local variable 'out' referenced before assignment\n7.7. Lab\nCopy classmates.py to classfilter.py\nAsk the user for a role on the command-line\nUsing a function and the builtin filter(), print a list of your classmates with that role");
        setContent("                                    7. Functions\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j18ActionPerformed

    private void j19ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j19ActionPerformed
        jTextPane1.setText("8.1. Basic Error Handling\nException handling in Python follows a similar pattern to many other languages wit this construct. The statements with exception handling are contained in a try block, followed by one or more except blocks. The except keyword is analogous to catch in some other languages.\n\nThe body of the try block is executed up to and including whatever statement raises (throws) an exception. At that point, the first except clause with an associated type that either matches, or is a supertype of, the exception raised will execute.\n\nIf no except clause matches, execution will exit the current scope and the process will continue back up the stack until the exception is handled or program execution terminates.\n\nRegardless of whether the exception is caught at the current execution level, the optional finally clause will execute if present. The finally clause will also execute if no exception is raised and is ideally suited for resource cleanup.\n\nIf no exception is raised, optional else block will be executed. The idea of an else block in exceptions is less common and designed to limit the contents of the try block, such that the types of exceptions being tested are quite explicit.\n\n>>> characters = {'hero': 'Othello', 'villain': 'Iago', 'friend': 'Cassio'}\n>>> def get_char(role):\n...     try:\n...         name = characters[role]\n...     except KeyError, e:\n...         result = 'This play has no %s' % role\n...     else:\n...         result = '%s is the %s' % (name, role)\n...     finally:\n...         result += ' and it\\'s a great play'\n...     return result\n...\n>>> get_char('champion')\n\"This play has no champion and it's a great play\"\n>>> get_char('friend')\n\"Cassio is the friend and it's a great play\"");
          setContent("                                    8. Exceptions\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j19ActionPerformed

    private void j20ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j20ActionPerformed
        jTextPane1.setText("In this section, well cover some of the tools you need as your scripts get to be bigger than just the contents of a single file. Namely code organization, command-line arguments and file I/O.\n\n9.1. Namespaces\nInside a single python module (file) there are multiple namespaces. The global namespace represents the full contents of the file, while inside each function there is a local namespace. The contents of these namespaces can be accessed as dictionaries using the functions globals() and locals() respectively.\n\nWhen objects (variables, functions, etc) are defined in the file, they manipulate the global namespace. Anything defined inside a function manipulates its local namespace. Notice in the example below that the namespace is manipulated as the file is read. In other words, the first print statement occurs before the interpreter is aware of the presence of the function definition.\n\n[Note]\tNote\nThe following example makes use of import, which will be explained in the next section. It also uses pprint.pformat which converts a dictionary into a string in a manner that is more easily read when printed.\n\norganization-1-namespaces.py. \n\n'''Some documentation for this file.'''\nimport pprint\n\nprint 'globals before def: %s\\n' % pprint.pformat(globals(), indent=4)\n\ndef simple():\n  print 'locals before a: %s\\n' % locals()\n  a = 'simple'\n  print 'locals after a: %s\\n' % locals()\n  return a\n\nprint 'globals after def: %s\\n' % pprint.pformat(globals(), indent=4)\n\nsimple()\n$ python organization-1-namespaces.py\nglobals before def: {   '__builtins__': <module '__builtin__' (built-in)>,\n    '__doc__': 'Some documentation for this file.',\n    '__file__': 'samples/organization-1-namespaces.py',\n    '__name__': '__main__',\n    '__package__': None,\n    'pprint': <module 'pprint' from '/opt/local/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/pprint.pyc'>}\n\nglobals after def: {   '__builtins__': <module '__builtin__' (built-in)>,\n    '__doc__': 'Some documentation for this file.',\n    '__file__': 'samples/organization-1-namespaces.py',\n    '__name__': '__main__',\n    '__package__': None,\n    'pprint': <module 'pprint' from '/opt/local/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/pprint.pyc'>,\n    'simple': <function simple at 0x100425f50>}\n\nlocals before a: {}\n\nlocals after a: {'a': 'simple'}\n9.2. Importing modules\nHave another look at an example similar to the one above. Notice that the modules that are imported are present in the global namespace.\n\norganization-2-imports.py. \n\nimport collections\nimport pprint\n\nd = collections.deque()\nd.append('a')\nd.appendleft('b')\n\npprint.pprint(globals())\n$ python organization-2-imports.py\n{'__builtins__': <module '__builtin__' (built-in)>,\n '__doc__': None,\n '__file__': 'samples/organization-2-imports.py',\n '__name__': '__main__',\n '__package__': None,\n 'collections': <module 'collections' from '/opt/local/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/collections.pyc'>,\n 'd': deque(['b', 'a']),\n 'pprint': <module 'pprint' from '/opt/local/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/pprint.pyc'>}\nObjects from this module are accessed using dotted notation.\n\nAlternatively, you can import the specific element from the module, using the from ... import syntax.\n\norganization-3-import-submodule.py. \n\nfrom collections import deque\nfrom pprint import pprint\n\nd = deque()\nd.append('a')\nd.appendleft('b')\n\npprint(globals())\n$ python organization-3-import-submodule.py\n{'__builtins__': <module '__builtin__' (built-in)>,\n '__doc__': None,\n '__file__': 'samples/organization-3-import-submodule.py',\n '__name__': '__main__',\n '__package__': None,\n 'd': deque(['b', 'a']),\n 'deque': <type 'collections.deque'>,\n 'pprint': <function pprint at 0x100435578>}\nIt is also possible to import an entire namespace. This should be done with caution, as it can lead to unexpected elements in your namespace and conflicts in naming.\n\norganization-4-import-all.py. \n\nfrom collections import *\nfrom pprint import pprint\n\nd = deque()\nd.append('a')\nd.appendleft('b')\n\npprint(globals())\n$ python organization-4-import-all.py\n{'Callable': <class '_abcoll.Callable'>,\n 'Container': <class '_abcoll.Container'>,\n 'Hashable': <class '_abcoll.Hashable'>,\n 'ItemsView': <class '_abcoll.ItemsView'>,\n 'Iterable': <class '_abcoll.Iterable'>,\n 'Iterator': <class '_abcoll.Iterator'>,\n 'KeysView': <class '_abcoll.KeysView'>,\n 'Mapping': <class '_abcoll.Mapping'>,\n 'MappingView': <class '_abcoll.MappingView'>,\n 'MutableMapping': <class '_abcoll.MutableMapping'>,\n 'MutableSequence': <class '_abcoll.MutableSequence'>,\n 'MutableSet': <class '_abcoll.MutableSet'>,\n 'Sequence': <class '_abcoll.Sequence'>,\n 'Set': <class '_abcoll.Set'>,\n 'Sized': <class '_abcoll.Sized'>,\n 'ValuesView': <class '_abcoll.ValuesView'>,\n '__builtins__': <module '__builtin__' (built-in)>,\n '__doc__': None,\n '__file__': 'samples/organization-4-import-all.py',\n '__name__': '__main__',\n '__package__': None,\n 'd': deque(['b', 'a']),\n 'defaultdict': <type 'collections.defaultdict'>,\n 'deque': <type 'collections.deque'>,\n 'namedtuple': <function namedtuple at 0x100425ed8>,\n 'pprint': <function pprint at 0x1004355f0>}\n9.3. Creating Modules\nOnce your code starts to get bigger than a script, you will want to start organizing it into modules. Unlike some other languages (Java for example) each file in Python is a module. Directories can also be used as a further layer of organization with some care.\n\nUsing the file-only model, functions can be created in another file in the same directory (or somewhere in the $PYTHONPATH) and imported using the filename and the function name.\n\ntools.py. \n\ndef shorten(toolong):\n    return toolong[:2]\ncomplexity-4-file-module.py. \n\nfrom tools import shorten\n\nprint shorten('abcdef')\n$ python complexity-4-file-module.py\nab\nAs code starts to require even more organization, perhaps with multiple types of utility functions, this file could be moved to a subdirectory. In order to use a directory as a module, it is required that the special file __init__.py be present in the directory, which can be empty.\n\n$ ls tools2\ntools2/__init__.py\ntools2/strings.py\ntools2/strings.py. \n\ndef shorten(toolong):\n    return toolong[:2]\ncomplexity-5-directory-module.py. \n\nfrom tools2 import strings\n\nprint strings.shorten('abcdef')\n$ python complexity-5-directory-module.py\nab");
        setContent("                                    9. Code Organization\n\n");
             jTabbedPane1.setSelectedIndex(2); // TODO add your handling code here:
    }//GEN-LAST:event_j20ActionPerformed

    private void j21ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j21ActionPerformed
        jTextPane1.setText("10.1. File I/O\nGetting data into and out of files in Python feels a lot like using the low-level methods of C, but it has all the ease of Python layered on top.\n\nFor example, to open a file for writing use the builtin (and very C-like) open() function. But then write the contents of a list with a single call. The open() function returns an open file object and closing the file is done by calling the close() method of that object.\n\n[Note]\tNote\nthe writelines() and readlines() methods in Python do not handle EOL characters on your behalf, making the naming a bit confusing. In this example, note the inclusion of the \\n character in the elements of the list.\n\n>>> colors = ['red\\n', 'yellow\\n', 'blue\\n']\n>>> f = open('colors.txt', 'w')\n>>> f.writelines(colors)\n>>> f.close()\nBy default, the open() function returns a file open for reading. Individual lines can be read with the readline() method, which will return an empty string. Since the zero-length string has is not truthy, it makes a simple marker.\n\n>>> f = open('colors.txt')\n>>> f.readline()\n'red\\n'\n>>> f.readline()\n'yellow\\n'\n>>> f.readline()\n'blue\\n'\n>>> f.readline()\n''\n>>> f.close()\nAlternatively, all of the lines of the file can be read into a list with one method call and then iterated over from there.\n\n>>> f = open('colors.txt')\n>>> f.readlines()\n['red\\n', 'yellow\\n', 'blue\\n']\n>>> f.close()\nHowever, for large files, reading the contents into memory can be impractical. So it is best to use the file object itself as an iterator, which will consume content from the file as needed with no intermediary memory requirement.\n\n>>> f = open('colors.txt')\n>>> for line in f:\n...     print line,\n...\nred\nyellow\nblue\n>>> f.close()\nIn order to ensure that the files in the above examples were properly closed, they should have been safe-guarded against an abnormal exit (by Exception or other unexpected return) using a finally statement. See the following example, where you can see in the final seek() that the file is closed in the case of proper execution.\n\n>>> f = open('colors.txt')\n>>> try:\n...     lines = f.readlines()\n... finally:\n...     f.close()\n...\n>>> lines\n['red\\n', 'yellow\\n', 'blue\\n']\n\n>>> f.seek(0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file\nIn the next example, the code path fails attempting to write to a file opened for reading. The file is still closed in the finally clause.\n\n>>> f = open('colors.txt')\n>>> try:\n...     f.writelines('magenta\\n')\n... finally:\n...     f.close()\n...\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nIOError: File not open for writing\n\n>>> f.seek(0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file\nAs of Python 2.6, there is a builtin syntax for handling this paradigm, using the with keyword. with creates a context and regardless of how that context is exited, calls the __exit__() method of the object being managed. In the following example, that object is the file f, but this model works for any file-like object (objects with the basic methods of files).\n\nOnce again, performing an operation on the file outside of that context shows that it has been closed.\n\n>>> with open('colors.txt') as f:\n...     for line in f:\n...         print line,\n...\nred\nyellow\nblue\n\n>>> f.seek(0)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: I/O operation on closed file\nAs mentioned above, file-like objects are objects that look and feel like files. In Python, there is no strict inheritance requirement in order to use an object as if it were another. StringIO is an example of a file-like object that manages its contents in memory instead of on disk.\n\nIt is important to be conscious of the file-like behavior here. Note that a seek is required after writing to get back to the beginning and read. Attempting to run the same iterator twice results in no values the second time through.\n\nStringIO.getvalue() returns a newly created string object with the full contents of the StringIO buffer.\n\n>>> colors = ['red\\n', 'yellow\\n', 'blue\\n']\n>>> from StringIO import StringIO\n>>> buffer = StringIO()\n>>> buffer.writelines(colors)\n>>> buffer.seek(0)\n\n>>> for line in buffer:\n...     print line,\n...\nred\nyellow\nblue\n\n>>> for line in buffer:\n...     print line,\n...\n\n>>> buffer.getvalue()\n'red\\nyellow\\nblue\\n'");
        setContent("                                   10. Working with Files\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j21ActionPerformed

    private void j22ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j22ActionPerformed
        jTextPane1.setText("11.1. Options\nEach script invoked from the command line in Python has access to any arguments in the sys.argv list. While the contents of this list are quite predictable, it is rarely necessary to handle them directly. The preferred option is to use the optparse module and the OptionParser class from that module.\n\nAn instance of OptionParser has methods for adding options (long and short flags) and including parameters with those options (if desired). The action to be taken when an option is encountered is also configurable, including setting a boolean flag, storing a value, or executing a callback function.\n\nDefaults and help text are also covered, as well as error handling. Here is a basic example using the standard features.\n\nThe call to parse_args() returns a two-tuple. The first item in the tuple is an options object containing any parameters or boolean values captured from the command line. The second item is a list containing any additional arguments passed at the end of the command line.\n\nfrom optparse import OptionParser\n\np = OptionParser()\n\np.add_option('-d', '--debug', action='store_true',\ndest='debug', help='Turn on debugging')\n\np.add_option('-s', '--speed', action='store',\ntype='int', dest='speed',\n   help='Use a bigger number to go faster')\n\np.add_option('-u', '--username', action='store',\ntype='string', dest='user',\n   help='Provide your username')\n\np.set_defaults(debug=False, speed=0)\n\noptions, args = p.parse_args()\n\nif options.user is None:\n    p.error('Username is required')\n\nprint 'debug option is: %s' % options.debug\nprint 'speed option is: %s' % options.speed\nprint 'args are: %s' % args\n$ python options.py\nUsage: options.py [options]\n\noptions.py: error: Username is required\nUnless modified in the creation, each instance of OptionParser adds a -h option to print help for the user.\n\n$ python options.py -h\nUsage: options.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  -d, --debug           Turn on debugging\n  -s SPEED, --speed=SPEED\n                        Use a bigger number to go faster\n  -u USER, --username=USER\n                        Provide your username\nIn the output below, note the value myfile.txt, which was not associated with any flag.\n\n$ python options.py -u me -s 9 myfile.txt\ndebug option is: False\nspeed option is: 9\nargs are: ['myfile.txt']");
         setContent("                                   11. Interacting with the Outside World\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j22ActionPerformed

    private void GetStarted2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GetStarted2ActionPerformed
        jTextPane1.setText("What is C++?\n\n\nC++ is a cross-platform language that can be used to create high-performance applications.\n\nC++ was developed by Bjarne Stroustrup, as an extension to the C language.\n\nC++ gives programmers a high level of control over system resources and memory.\n\nThe language was updated 3 major times in 2011, 2014, and 2017 to C++11, C++14, and C++17.\n\n\n\nWhy Use C++\nC++ is one of the world's most popular programming languages.\n\nC++ can be found in today's operating systems, Graphical User Interfaces, and embedded systems.\n\nC++ is an object-oriented programming language which gives a clear structure to programs and allows code to be reused, lowering development costs.\n\nC++ is portable and can be used to develop applications that can be adapted to multiple platforms.\n\nC++ is fun and easy to learn!\n\nAs C++ is close to C# and Java, it makes it easy for programmers to switch to C++ or vice versa\n\n");
         setContent("                                    1.Introduction\n\n");
             jTabbedPane1.setSelectedIndex(2);        // TODO add your handling code here:
    }//GEN-LAST:event_GetStarted2ActionPerformed

    private void cp1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cp1ActionPerformed
        jTextPane1.setText("What is C++?\n\n\nC++ is a cross-platform language that can be used to create high-performance applications.\n\nC++ was developed by Bjarne Stroustrup, as an extension to the C language.\n\nC++ gives programmers a high level of control over system resources and memory.\n\nThe language was updated 3 major times in 2011, 2014, and 2017 to C++11, C++14, and C++17.\n\n\n\nWhy Use C++\nC++ is one of the world's most popular programming languages.\n\nC++ can be found in today's operating systems, Graphical User Interfaces, and embedded systems.\n\nC++ is an object-oriented programming language which gives a clear structure to programs and allows code to be reused, lowering development costs.\n\nC++ is portable and can be used to develop applications that can be adapted to multiple platforms.\n\nC++ is fun and easy to learn!\n\nAs C++ is close to C# and Java, it makes it easy for programmers to switch to C++ or vice versa\n\n");
         setContent("                                    1.Introduction\n\n");
             jTabbedPane1.setSelectedIndex(2);
    }//GEN-LAST:event_cp1ActionPerformed

    private void j24ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j24ActionPerformed
        jTextPane1.setText("Introduction\nTerminology:\n\nComputer program: sequence of statements designed to accomplish some task\nProgramming: planning/creating a program\nSyntax: rules that specify which statements (instructions) are legal\nProgramming language: a set of rules, symbols, and special words\nSemantic rule: meaning of the instruction\n_____________________________________________________________________________________________\nC++ Programs\n\nC++ Program Basics:\n\nProgramming instructions must be written according to syntax rules\nCompiler checks that program follows syntax rules\nMetalanguage: term used to describe syntax rules\nC++ program: collection of one or more subprograms--called functions\nSubprogram or function is collection of statements that, when invoked, performs some task\nEvery C++ program has one and ONLY one function called main()\nToken: smallest individual program unit\nToken: divided into special symbols, word symbols, and identifiers\n_____________________________________________________________________________________________________________________________________________________________________________\nSymbols\nSpecial Symbols:\n\nInclude mathematical symbols and punctuation marks\nBlank also special symbol\nSome tokens made up of two characters (with no blank)--still considered as single symbol\nSpecial Symbol Examples:\n+     ? \n-     ,\n*     <=\n/     !=\n.     ==\n;     >=  \n________________________________________________________________________________________________________________________________________________________________________\nWord Symbols:\nAnother type of token\nReserved words or keywords\nReserved words: always lowercase, each considered to be single symbol with special meaning\nWord Symbol Examples:\nint\nfloat\ndouble\nchar\nvoid\nreturn  \nIdentifiers\n_______________________________________________________________________________________________________________________________________________\n\nData Types\nUsing Data Types:\n\nSet of values together with set of operations called data type\nC++ data types classified into three categories:\n1. Simple data type\n2. Structured data type\n3. Pointers\n\n1. Simple Data Types (three categories):\ni. Integral: integers (numbers without a decimal)\nii. Floating-point: decimal numbers\niii. Enumeration type: user-defined data type\n\nIntegral Data Types (further classified):\n1. char\n2. short\n3. int\n4. long\n5. bool\n6. unsigned char\n7. unsigned short\n8. unsigned int\n9. unsigned long\n\nEach data type associated with different set of values\nSize of number represented determines data type\nData type determines amount of memory used\nShould use most efficient data type for program requirements\nDifferent compilers may have different range of values for each data type\n\nint Data Type:\nNumbers with no decimal point\nPositive integers do not require + sign in front of them (but, can include +)\nNo commas are used within integer\n***Commas used for separating items in a list***\nint Data Type Examples:\n-6728\n0\n78\n\nbool Data Type:\nTwo values: true and false, called logical (or Boolean) values\nAn expression that evaluates to true or false called logical (Boolean) expression\nIn C++, bool, true, and false are reserved words\nOlder compilers do not include bool data type\n\nchar Data Type:\nSmallest integral data type\nCan hold numeric values -128 to 127\nUsed to represent characters: letters, digits, and special characters\nchar data type can represent each character on keyboard\nchar data values represented within single quotation marks (e.g., 'r')\nBlank is represented as ' ' (space between single quotes)\nchar Data Type Examples:\n 'A', 'a', '0', '*', '+', '$', '&' \n\nFloating-Point Data Types:\nRepresent numbers with decimal points (real numbers)\nC++ uses form of scientific notation called floating-point notation\nIn C++, letter E (or e) represents the exponent\nFloating-Point Data Types (further classified):\nfloat\ndouble\nlong double\nEach data type associated with different set of values\nSize of number represented determines data type\nData type determines amount of memory used\nfloat data type:\nfloat data type:\nRange: -3.4E+38 to 3.4E+38\nMemory allocated: 4 bytes\nMaximum number of significant digits (decimal places): 6 or 7\nFloat values called single precision\n\ndouble data type:\nRange: -1.7E+308 to 1.7E+308\nMemory allocated: 8 bytes\nMaximum number of significant digits (decimal places): 15\nDouble values called double precision\nPrecision: maximum number of significant digits\nShould use most efficient data type for program requirements\nDifferent compilers may have different range of values for each data type\nMost newer compilers, double and long double are same\nFloating-Point Data Type Examples:\nReal Number   C++ Floating-Point Notation\n75.924        7.592400E1\n0.18          1.800000E-1\n0.0000453     4.530000E-5\n-1.482        -1.482000E0\n7800.0        7.800000E3\n***Some compilers, default constant float values to double, and provide a warning when assigning constant float values to float data type variables. You may want to declare float data values as double to eliminate warnings.***\n\nstring Type:\nProgrammer-defined data type (not included in earlier versions of C++)\nTo use string data type, string library must be included (include file)\nSequence of zero or more characters\nEnclosed in double quotation marks (e.g., \"r\")\nnull string: string with no characters\nEach character in string has a relative position\nPosition of first character is 0 (zero), 2nd character is 1, etc.\nLength of string is total number of characters (e.g., \"C++\" length = 3)\nArithmetic Operators and Operator Precedence\n_______________________________________________________________________________________________________________________________________________________________________________\nUsing Arithmetic Operators and Operator Precedence:\n\nOperations inside of parentheses () are evaluated first\n+, -, *, and / can be used with integral and floating-point data types\n% modulus operator only used with integral types\nWhen dividing integral values, quotient truncated, not rounded\nUnary operator: used with only one operand\nBinary Operator: used with two operands\nC++ Mathematical Operators (in order of precedence):\n1) *   multiplication\n1) /   division\n1) %   remainder (modulus operator)\n2) +   addition\n2) -   subtraction\n***Operators having same level of precedence are evaluated from left to right.***\nExpressions\n_____________________________________________________________________________________________________________________________________________________________________\n\n\nUsing Expressions:\n\nIntegral expression: all operands are integers\nFloating-point expression: all operands are floating-point\nIntegral expression yields integral result\nFloating-point expression yields a floating-point result\nMixed expression: operands are integers and floating-point\nMixed expression yields a floating-point result (integer changed to floating-point)\nMixed Expression Examples:\n2 + 3.5 = 5.5\n6  /  4 + 3.9 = 4.9\n5.4  *  2 - 13.6 + 18  /  2 = 6.200000000000001\nType Conversion (Casting):\nImplicit type coercion: value of one type is automatically (implicitly) changed to another type\nExplicit type conversion: use cast operator (two forms)\nstatic_cast<dataTypeName>(expression): more stable\ndataType(expression): C-style typecasting\nType Casting Examples:\nstatic_cast<float>(5) = 5.0\nint(5.5) = 5 //C-style typecasting\nint('A') = 65 //C-style typecasting\n***Remember: char data type yields an integral value. Review (ASCII table).***\n_______________________________________________________________________________________________________________________________________________________________________________\n\nInput, Memory, and Data\n\n\nUsing Input:\n\nData must be loaded into main memory before it can be manipulated\nStoring data in memory is two-step process:\nInstruct computer to allocate memory\nInclude statements to put data into allocated memory\nAllocating Memory (Constants and Variables):\nName and define data type to store data for each memory location\nDeclaration statement used to allocate memory\nVariables: memory cells whose contents can be modified during program execution\nPossible to declare multiple variables in same statement (must be same type)\nNamed Constant: memory location whose data cannot change during program execution\nUsing named constant simplifies code modification - change in declaration statement affects code globally\nIn C++, const is reserved word\nFour characteristics of variables:\nName\nType\nSize\nValue\nSyntax for declaring variables to allocate memory:\n\n\ndataType identifier;\n\nExamples:\nint myVar; //declares one int variable\nfloat myFloat, myFloat2, myFloat3; //declares three float variables\nSyntax for declaring named constants to allocate memory (uses keyword const and must assign value):\nconst dataType identifier = value;\n\nExample:\nconst double PI = 3.14;\nStoring Data into Variables (declaring and initializing variables):\nVariables can be declared anywhere in program\nMust be declared before can be used\nIn C++, = called assignment operator\nData stored in memory (using name of variable or constant), either using assignment statement or input statement\nC++ does not automatically initialize variables\nWhen variable declared, only memory is allocated\nWhen variable declared with no value, memory cell may contain value from setting of bits from previous use\nExpression on right side is evaluated, then its value is assigned to variable (a memory location) on left side\nVariable initialization: variable given a value at declaration (good programming principle)\nRemember: assignment (=) is NOT equality (==)\nAssignment Statement Examples:\nvariable = expression;\n\nmyVar = 10; //assigns value of 10 to myVar\n\nint i; //allocates memory for variable i\ni = i + 2; //evaluates i (right side), adds two to it, and assigns new value to memory location i (left side)\nInitialization Statement Examples:\nint variable = expression;\n\nint myVar = 10; //allocates memory for variable myVar, and assigns value of 10 to myVar\n\n//declares two double variables (myDouble and myDouble3), initializes myDouble2 with value of 25.5\ndouble myDouble, myDouble2=25.5, myDouble3;\nInput (Read) Statement:\ncin used with >> (stream extraction operator) to gather input\nWhen value for variable not known before program is written--value input through cin and >>(stream extraction operator)\nInput (Read) Statement Examples:\ncin >> variableName >> variableName. . .;\n\ncin >> miles; //computer gets value from standard input device, and places value in memory cell named miles\n\ncin >> feet >> inches; //input multiple values into multiple memory locations with single statement  \nProblems Using Mixed Values:\nAssigning Mixed Values:\nAssigning floating-point value to int type variable - fractional part dropped (truncated)\nAssigning integer value to floating-point type variable - adds decimal point (.) and 0 (zero)\nReading Mixed Values:\nReading (cin >>) floating-point value into int type variable, reading stops at decimal point\nRemaining value stays in buffer\nMay get error on next read\nReading integer value into floating-point type variable - adds decimal point (.) and 0 (zero)\n***Problems occur ONLY when placing floating-point values into int type variables, NOT the reverse.***\n___________________________________________________________________________________________________________________________________________________________\n\n\nIncrement and Decrement Operators\nUsing Increment and Decrement Operators:\n\nIncrement operator (++) increases value of variable by 1\nDecrement operator (--) decreases value of variable by 1\nIncrement and decrement operators each have two forms: prefix and postfix\n\nPrefix syntax:\n++ variable or --variable\n\nPostfix syntax:\nvariable++ or variable--\n\nPrefix and Postfix Operator Differences:\nPrefix and postfix operators used as stand-alone statement--results are same:\nx = 0;\n\n//either way, x = 1 \n++x;\nx++;\nDifferences in prefix and postfix operators occur in assignment:\n//First statement assigns 0 to x\n//Second statement increments x to 1 and assigns 1 to y.  Both have the value of 1\nx = 0; \ny = ++x;\n\n//versus...\n\n//First statement assigns 0 to x\n//Second statement assigns 0 to y and increments x to 1\n//Result: x evaluates to 1 and y evaluates to 0  \n//***Parentheses can override order of operations***\nx = 0; \ny = x++;\n\n___________________________________________________________________________________________________________________________________________________________________________\n\n\nOutput\nUsing Output:\n\nOutput statement written with cout and stream insertion operator (<<)\nStandard output device normally monitor screen\nTo move cursor to beginning of next line requires either predefined word endl, with insertion operator (<<), or escape sequence '\\n'\nIn C++, \\ called escape character and \\n called newline escape sequence\nTo include cin and cout, appropriate header file must be included:\n\n#include <iostream>\nEscape Sequence Examples:\n  \\n\t//Newline: cursor moves to beginning of next line\n  \\t\t//Tab: cursor moves to next tab stop\n  \\b\t//Backspace: cursor moves one space left\n  \\r\t//Return:\tcursor moves to beginning of current line (not next line)\n  \\\\\t//Backslash: backslash printed\n  \\'\t//Single quotation: single quotation mark printed\n  \\\"\t//Double quotation: double quotation mark printed\nPreprocessor Directives:\nIn C++, most operations and functions must be imported from collection of libraries\nFor example, for input/output, header file iostream must be included\nPreprocessor directives (i.e., names of header files) tell computer where to locate required libraries\nPreprocessor directives processed by program called preprocessor--before program goes through compiler\nPreprocessor commands begin with #--must appear at beginning of program\nGeneral syntax:\n#include<headerFileName>\nUsing cin/cout and namespace:\nC++ program contains two parts:\nPreprocessor directives (include header files)\nThe program\nPreprocessor directives and program statements create C++ source code\nSource code must be saved in file with file extension .cpp\nGeneral syntax:\n#include <iostream>\nusing namespace std;\nCompiler generates object code\nSaved in file with .obj file extension\nExecutable code produced and saved in file with .exe file extension\nCommonly used header files:\nOlder versions of C++, header files had file extension .h (using no namespace)\nIn (ANSI/ISO Standard) C++, cin/cout declared in header file iostream, within namespace std\nANSI C++ removes extension\nTo use cin and cout, use following two statements:\n#include <iostream>\nusing namespace std;\nCommonly used header files:\n<iostream>  //input/output \n<cmath>  //math functions\n<string>  //string functions\n<iomanip>  //formatting manipulations for input/output\nUsing string Data Type:\nMust access definition from header file string\nInclude following preprocessor directive:\n#include<string>\nCreating a C++ Program\nPutting It Together:\n\nTwo Parts:\nPreprocessor directives (include files)\nThe program\nPreprocessor directives and program statements constitute C++ source code\nSource code saved in file with file extension .cpp\nCompiler generates object code (saved in file with .obj file extension)\nExecutable code produced (saved in file with .exe file extension)\nC++ Program Form and Style:\nEvery C++ program MUST have one and ONLY one function main()\nBasic parts of function main() (as with any other C++ function):\nFunction Heading\nFunction Body\nSyntax errors found in compilation (i.e., by compiler)\nUse of Blanks:\nOne or more blanks separate input numbers\nBlanks also used to separate reserved words, identifiers,and other symbols\nSemicolons, Brackets, and Commas:\nAll C++ statements end with a semicolon (statement terminator)\nBrackets {} separate blocks of code\nCommas separate items in a list\nSemantics (meaning or interpretation):\nProgram may not run, or run improperly, even with syntax errors removed\nFor example, 2 + 3 * 5 and (2 + 3) * 5\nboth are syntactically correct expressions, with different meanings\nDocumentation:\nComments help document code:\nSingle line comments begin with //, multiple line comments enclosed between /* and */\nIdentifiers should employ meaningful names (e.g., firstName, empID)\nIdentifiers using more than one word: capitalize first letter of each new word, or use underscore between each word\nUser Prompts:\nWhen program input through keyboard is expected, must inform user\nPrompt commands: statements that inform user of expected input\nAdditionally, \"echo\" print user input for verification\nMore on Assignment Statements:\nCompound assignment statements: shorthand method of assignment\nCompound assignment defined: op is binary arithmetic operator, op=\nSimple assignment statement variable = variable op (another variable or expression);\nRewritten as compound assignment: variable op= (another variable or expression);\nExample:\n+=, -=, *=, /=, and %=\n\nx *= y; //equivalent to x = x * y;\nSimple Program:\nBegin program with comments for documentation\nInclude header files\nDeclare named constants, if any\nWrite definition of function main()\nSummary:\nProgram begins with comments (documentation)\nSystem resources used for I/O\nInput statements: get data (e.g., keyboard, file, etc.)\nOutput statements: print/display (or echo) results (e.g., screen, file, etc.)\nFirst statement of program--after comments--is preprocessor directive\nPreprocessor directive includes header file (e.g., iostream)\nTwo types of memory locations for data manipulation:\nNamed constants (usually put before main when used throughout program)\nVariables\nProgram must contain at least one function: main()\nVariables to manipulate data, can be declared in function main()\nBody of function main() has following form:\nint main ()\n{\n  variable declarations;\n  statements...;\n  return 0;\n}");
        setContent("                                    2. Basic C++ Elements\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j24ActionPerformed

    private void j25ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j25ActionPerformed
        jTextPane1.setText("C++ Basic Input/Output\nIn this tutorial, we will learn to use the cin object to take input from the user, and the cout object to display output to the user with the help of examples.\n\n\nC++ Output\nIn C++, cout sends formatted output to standard output devices, such as the screen. We use the cout object along with the << operator for displaying output.\n\nExample 1: String Output\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // prints the string enclosed in double quotes\n    cout << \"This is C++ Programming\";\n    return 0;\n}\nOutput\n\nThis is C++ Programming\nHow does this program work?\n\nWe first include the iostream header file that allows us to display output.\nThe cout object is defined inside the std namespace. To use the std namespace, we used the using namespace std; statement.\nEvery C++ program starts with the main() function. The code execution begins from the start of the main() function.\ncout is an object that prints the string inside quotation marks \" \". It is followed by the << operator.\nreturn 0; is the \"exit status\" of the main() function. The program ends with this statement, however, this statement is not mandatory.\nNote: If we don't include the using namespace std; statement, we need to use std::cout instead of cout.\n\nThis is the preferred method as using the std namespace can create potential problems.\n\nHowever, we have used the std namespace in our tutorials in order to make the codes more readable.\n\n#include <iostream>\n\nint main() {\n    // prints the string enclosed in double quotes\n    std::cout << \"This is C++ Programming\";\n    return 0;\n}\nExample 2: Numbers and Characters Output\n\nTo print the numbers and character variables, we use the same cout object but without using quotation marks.\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int num1 = 70;\n    double num2 = 256.783;\n    char ch = 'A';\n\n    cout << num1 << endl;    // print integer\n    cout << num2 << endl;    // print double\n    cout << \"character: \" << ch << endl;    // print char\n    return 0;\n}\nOutput\n\n70\n256.783\ncharacter: A\nNotes:\n\nThe endl manipulator is used to insert a new line. That's why each output is displayed in a new line.\nThe << operator can be used more than once if we want to print different variables, strings and so on in a single statement. For example:\ncout << \"character: \" << ch << endl;\nC++ Input\nIn C++, cin takes formatted input from standard input devices such as the keyboard. We use the cin object along with the >> operator for taking input.\n\nExample 3: Integer Input/Output\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int num;\n    cout << \"Enter an integer: \";\n    cin >> num;   // Taking input\n    cout << \"The number is: \" << num;\n    return 0;\n}\nOutput\n\nEnter an integer: 70\nThe number is: 70\nIn the program, we used\n\ncin >> num;\nto take input from the user. The input is stored in the variable num. We use the >> operator with cin to take input.\n\nNote: If we don't include the using namespace std; statement, we need to use std::cin instead of cin.\n\nC++ Taking Multiple Inputs\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char a;\n    int num;\n\n    cout << \"Enter a character and an integer: \";\n    cin >> a >> num;\n\n    cout << \"Character: \" << a << endl;\n    cout << \"Number: \" << num;\n\n    return 0;\n}\nOutput\n\nEnter a character and an integer: F\n23\nCharacter: F\nNumber: 23");
            setContent("                                    3. Input/Output\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j25ActionPerformed

    private void j26ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j26ActionPerformed
                       jTextPane1.setText("Control Structures - Selection\nUsing Control Structures:\n\nAlgorithm: A procedure for solving a problem in terms of\nthe actions to execute\nthe order in which the actions will execute\nPseudocode: \"fake\" code\ndescribes the action statments in English\nhelps a programmer \"think out\" the problem and solution but does not execute\nFlow of Control/Execution: implemented with three basic types of structures\nSequential: default mode; Executed line by line, one right after the other\nSelection: decisions, branching; When there are 2 or more alternatives. Three types:\nif\nif...else\nswitch\nRepetition: used for looping, or repeating a section of code multiple times. Three types:\nwhile\ndo...while\nfor\nTrue and False\nStatements that are executed are dependent on certain conditions that are evaluated either true or false.\nCondition represented by logical (Boolean) expression - can be true or false\nCondition met if evaluates to true\nKey: Any C++ expression taht evaluates to a value can be interpreted as a true/false condition.\nAn expression that evaluates to 0 is false.\nAn expression that evaluates to a non-zero value is true.\nRelational Operators\n\n\nUsing Relational Operators:\n\nRelational operators:\nAllow comparisons\nRequire two operands (binary)\nReturn 1 (or nonzero integer) if expression true, otherwise 0 false\nComparing values of different data types may produce unpredictable results\nFor example: 6 < '5' (compares integer 6 with character '5')\nRelational Operator Examples:\nEach of the following returns a true or false.\nCommonly used as test expressions in selection and repetition statements.\n==  equal to\nx == y\n\n!=  not equal to\nx != y\n\n<  less than\nx < y\n\n<=  less than or equal to\nx <= y\n\n>  greater than\nx > y\n\n>=  greater than or equal to\nx >= y\n\n***BE CAREFUL!\n'a' < 'A' evaluates to false!\n***Under the ASCII Collating Sequence: numbers < ucase letters < lcase letters\nASCII Chart\n\nComparing string Types:\nRelational operators can be applied to strings\nStrings: compared character by character, beginning with first character\nComparison continues until either mismatch found, or all characters found to be equal\nIf two strings of different lengths compared, and comparison equal to last character of shorter string,\nshorter string is evaluated as \"less\" than larger string\nstring Comparison Examples:\nDeclarations:\nstring str1 = \"Hello\";\nstring str2 = \"Hi\";\nstring str3 = \"Ann\";\nstring str4 = \"Bill\";\n\nstr1 < str2 //true: second character 'e' less than 'i'\nstr4 < str3 //false: first character 'B' greater than 'A'\nstr3 >= \"An\" //true: characters are equal, but str3 is longer than \"An\"\n\n________________________________________________________________________________________________________________________\n\nLogical (Boolean) Operators\nUsing Logical (Boolean) Operators:\n\nLogical (Boolean) operators take logical values as operands, and yield logical values as results\nThree logical (Boolean) operators:\n! (not)\n&& (and)\n|| (or)\n! is unary; && and || are binary operators\n! in front of logical expression reverses value\ntrue and false are keywords\ntrue (nonzero)\nfalse (0)\n\n_____________________________________________________________________________________________________________________\n\nLogical (Boolean) Expressions\nTo clarify the differences between using the logical (boolean) operators AND &&, OR ||, and bitwise operators AND &, OR |:\n\nFirst of all, let me preface any comments by saying when using && or &, and || or |, ultimately the results are the SAME. When using && or & operators, both operands must be true, otherwise, false. When using || or | operators, both operands must be false, otherwise, true. The difference lies in the evaluation PROCESS.\n\nShort-circuit evaluation: evaluation of a logical expression stops as soon as the value of the expression is known. When the && operator is used to compare a logical expression, the compiler will stop the evaluation upon the first false condition, unlike the & operator which will continue to evaluate the ensuing expression(s) being compared. The same holds true for the operators || and |, when evaluating true conditions.\n\nWith respect to logical vs. bitwise operators, there is a difference between using the logical \"and\" (&&), rather than the bitwise \"and\" (&). And, yes, there is a very important difference--and, no \"one size fits all\" solution:\n\nWhen the logical (&&) operator is used to compare a logical expression, the compiler will stop the evaluation upon the first false condition, unlike the & operator which will continue to evaluate the ensuing expression(s) being compared.\nif(++myVal % 2 == 0 && ++count < limit)\n   // Do something\nIf the left hand operand is evaluated to be false (++myVal % 2 == 0), the compiler will stop and not evaluate the right-hand operand (++count < limit). More importantly, if myVal is not an even number, count will NOT increment.\n\nThis may be fine, IF count doesnt need to increment every time. Though, if it does, use the bitwise \"and\" (&) operator to evaluate both expressions. As the following example:\nif(++myVal % 2 == 0 & ++count < limit)\n   // Do something\nAgain, fundamentally, the logical result is the same (i.e., a truth table) for both & and &&: \"Do something\" only will be executed if BOTH expressions are true. The benefit is that the bitwise \"and\" (&) operator will allow count to increment.\n\nOn the other hand, you may not want the right hand expression to be evaluated (that is, use && not &). Example:\nIf(count > 0 && total/count > 5)\nHere, it's easy to see that one would NOT want a compile or run-time error if the value of count were 0!\n\nLastly, the same \"truth table\" logic holds true for logical \"or\" (||) vs. the bitwise \"or\" (|). That is, the || operator is like && in that the right hand operand is NOT evaluated if the left hand operand is TRUE. You would need to use | if you wanted BOTH expressions to be evaluated.\nUsing bool Data Type and Logical (Boolean) Expressions:\nbool data type uses logical (Boolean) values true and false\nbool, true, and false are reserved words\nIdentifier true contains value 1\nIdentifier false contains value 0\nBe careful when using logical expressions:\n0 <= x <= 10 (Incorrect)\nAlways evaluates to true because 0 <= x evaluates to either 0 or 1, and 0 <= 10 is true and 1 <= 10 is true\n0 <= x && x <= 10 (Correct)\n\n_______________________________________________________________________________________________________________________________________________\n\nOperator Precedence and Associativity\nTwo operator characteristics determine how operands group with operators: precedence and associativity. Precedence is the priority for grouping different types of operators with their operands. Associativity is the left-to-right or right-to-left order for grouping operands to operators that have the same precedence. An operator's precedence is meaningful only if other operators with higher or lower precedence are present. Expressions with higher-precedence operators are evaluated first. The grouping of operands can be forced by using parentheses.\n\nAlso, operators follow a strict precedence, which defines the evaluation order of expressions containing these operators. Operators associate with either the expression on their left or the expression on their right; this is called \"associativity.\" The following table shows the precedence and associativity of C++ operators (from highest to lowest precedence). Operators in the same segment of the table have equal precedence and are evaluated left to right in an expression unless explicitly forced by parentheses.\nOperator Precedence and Associativity 1\nAnd...\nOperator Precedence and Associativity 2\nMnemonic: \"Math Relates Logically\"\nGenerally, the following 3 types of operators are evaluated in the following order: 1. Mathematical, 2. Relational, 3. Logical\nOperators with same level of precedence evaluated from left to right\nUnary operators have higher order of precedence than binary operators: e.g., logical not (!), unary minus (-), unary plus (+)\nAssociativity is left to right for most mathematical, relational, and logical operators\nUnary operators are right associative: e.g., logical not (!), unary minus (-), unary plus (+)--not including some postfix operators\nParentheses can be used to override precedence\nOrder of Precedence Examples (for complete listing, see links above):\n\n_______________________________________________________________________________________________________________________________________________\n\nOne-Way (if) Selection\nUsing One-Way (if) Selection:\n\nSyntax of one-way (if) selection:\nif (expression)\n  statement1;\n  statement2;\nif is reserved word\nexpression must evaluate to true (nonzero) or false (0)\nstatement1 executed if value of expression true\nstatement1 bypassed if value false; program execution moves to statement2\nstatement2 is executed regardless\nif (grade >= 90)\n  cout << \"Student has an A\";\n\n_______________________________________________________________________________________________________________________________________________\n\nTwo-Way (if...else) Selection\nUsing Two-Way (if...else) Selection:\n\nSyntax of two-way (if...else) selection:\nif (expression)\n  statement1;\nelse\n  statement2;\nIf expression true, statement1 executed, otherwise statement2 executed\nelse is reserved word\nCompound (Block) Statement\nUsing Compound (Block) Statement:\n\nSyntax of compound statement (or block of statements):\n{\n statement1;\n statement2;\n .\n .\n .\n statementn;\n}\nCompound statement treated as single statement\nCompound Statement Example:\nif (age > 18)\n{\n  cout << \"Eligible to vote.\" << endl;\n  cout << \"No longer a minor.\" << endl;\n} \nelse\n{\n  cout << \"Not eligible to vote.\" << endl;\n  cout << \"Still a minor.\" << endl;\n}\n\n______________________________________________________________________________________________________________________________________________\n\nNested if and if...else Statements\nUsing Nested if and if...else Statements:\n\nNesting: one control statement in another\nUse consistent layout for readability\nelse always belongs to closest if without an else\nSyntax of nested if...else statements:\n{\nif (condition1) \n  statement1; \nelse if (condition2) \n  statement2; \n. . . \nelse if (condition-n) \n  statement-n; \nelse \n  statement-z; \n}\nExample 1:\n{\nif (x < 0)\n  y = -1;\nelse if (x == 0)\n  y = 0;\nelse       //(x > 0)\n  y = 1;\n}\nExample 2:\n{\nif (x < 0)\n  y = -1;\nif (x == 0)\n  y = 0;\nif (x > 0)\n   y = 1;\n}\nExample 2 not recommended: a) not clear that only one statement will be executed for given value of x; b) inefficient since all conditions are always tested!\nPreventing Input Failure Using if Statement\nUsing if Statement to Prevent Input Failure:\n\nWhen input stream enters fail state:\nAll subsequent input statements associated with stream ignored\nProgram continues to execute--though, may produce erroneous results\nCan use if statements to check status of input stream\nIf stream enters fail state, include instructions to halt program execution\nConditional Operator (?:)\nUsing if Statement to Prevent Input Failure:\n\n\"Short-hand\" version of if...else statement\nConditional operator (?:) takes three arguments (ternary operator)\nSyntax for using conditional operator:\ntest_expression ? true_expression : false_expression\nIf test_expression true, true_expression is invoked; otherwise, false_expression is invoked\ncout << (x > y ? \"x is greater than y\" : \"x is less than or equal to y\");\n//Equivalent to\nif (x > y)\n  cout << \"x is greater than y\";\nelse\n  cout << \"x is less than or equal to y\");\n\n______________________________________________________________________________________________________________________________________________\n\nswitch Structures\nUsing switch Structures:\n\nConvenient when there are multiple cases to choose from.\nswitch structure: alternate to if...else\nswitch expression evaluated first (must be integral value) then compared to values in case labels. If a match is found, execution jumps to that case label.\nValue of expression determines corresponding action\nOne or more statements may follow case label\nBraces not required to execute multiple statements (different to other structures)\nRequired statements: switch, case\nOptional statements: break, default\nbreak statement may or may not appear after each statement\nTo execute only the code that matched the case, end with a break statement\nOtherwise execution will continue to the next case\nswitch, case, break, and default are reserved words\nWhen value of expression matched against case value,\nstatements execute until break statement found, or end of switch structure reached\nIf value of expression does not match any case values, statements following default label execute\nIf no default label, and no match, entire switch statement skipped\nbreak statement invokes immediate exit from switch structure\nswitch statement can evaluate expression for multiple values\n\n");
             setContent("                                    4. Selection Structures\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j26ActionPerformed

    private void j27ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j27ActionPerformed
        jTextPane1.setText("Repetition Structures\nWhy Repetition is Needed:\n\nRepetition structures, or loops, are used when a program needs to repeatedly process one or more instructions until some condition is met, at which time the loop ends. Many programming tasks are repetitive, having little variation from one item to the next. The process of performing the same task over and over again is called iteration, and C++ provides built-in iteration functionality. A loop executes the same section of program code over and over again, as long as a loop condition of some sort is met with each iteration. This section of code can be a single statement or a block of statements (a compound statement). Loops and Using Loops\n\nRepetition allows the programmer to efficiently use variables\nCan structure programming statements to be repeated as long as specific conditions are met\nFor example: can input, add, and average multiple numbers using limited number of variables\nThere are three looping structures in C++: 1. while loop, 2. for loop, and 3. do...while Loop\nMnemonic: \"ALL loops must have ITU\"--Initialize, Test, Update\nTypes of Repetition Structures\nTwo types of repetition structures: pretest and posttest loops\n_____________________________________________________________________________________________________________________________________________________________\n\nPretest:\n\nLoop condition appears at beginning of pretest loop\nDetermines number of times instructions w/in loop body are processed\nTypes of pretest loop:\n->while\n->for\n\n____________________________________________________________________________________________________________________________________________________________\nPosttest:\nLoop condition appears at end of posttest loop\nDetermines number of times instructions w/in loop body are processed\nHOWEVER, instructions processed at least once--the first time!\nTypes of posttest loop:\ndo...while while\nCounter-Controlled Repetition Requires\nthe name of a control variable (or loop counter)\nthe initial value of the control variable\nthe loop-continuation condition that tests for the final value of the control variable to determine when to exit\nthe control variable to be incremented (or decremented) each time through the loop\n***ALL LOOPS: if loop body contains more than one statement, statements must be entered as a statement block--that is, in a set of braces {}.\n\n_________________________________________________________________________________________________________________________________________________________________\n\nwhile Loop\nUsing while Loop:\n\nExecutes from zero to many times, depending on expression\nwhile is reserved word\nSyntax of while statement:\nwhile (expression)\n  statement;\nExpression provides entry condition\nExpression (parentheses must be included as part of syntax) must evaluate to true to invoke loop statement(s)\nStatement(s) can be simple or compound (block)\nStatement(s) is/are body of loop\nBE SURE to include an exit condition that will eventually evaluate expression to be false\nInfinite loop: statement(s) continue(s) to execute endlessly\nLoop invocation:\nStatement(s) execute(s) if expression evaluates to true\nLoop condition reevaluated\nStatement(s) continue(s) to execute until expression false\nCounter-Controlled while Loops:\nWhen programmer knows exactly how much data should be read\nSyntax of counter-controlled while statement:\nint counter=0; //initialize loop control variable\n\nwhile (counter < n) //test loop control variable\n{\n.\n.\n.\n  counter++; //update loop control variable\n.\n.\n.\n}\nExample 1:\nint counter=1; //initialize loop control variable\n\nwhile (counter < 11) //test loop control variable\n{\n  cout << i << endl; //print value of i\n  counter++; //update loop control variable\n}\nExample 2:\n//printing 1 - 10 using while loop\ncout << \"while loop prints 1 - 10\" << endl;\nint num=1;\nwhile(num < 11)\n  {\n    cout << num << endl;\n    ++num;\n  }\nSentinel-Controlled while Loops:\nSentinel variable tested in condition; loop ends when sentinel encountered\nSyntax of sentinel-controlled while statement:\ncin >> variable;  //initialize loop control variable\n\nwhile (variable != sentinel) //test loop control variable\n{\n.\n.\n.\n  cin >> variable;  //update loop control variable\n.\n.\n.\n}\nFlag-Controlled while Loops:\nflag-controlled while loop uses bool variable to control loop\nSyntax of flag-controlled while statement:\nbool found = false;  //initialize loop control variable\n\nwhile (!found) //test loop control variable\n{\n.\n.\n.\n  if (expression)\n    found = true;  //update loop control variable\n.\n.\n.\n}\nEOF (end of file)-Controlled while Loops:\nbool value returned by cin determines if program has input\nSyntax of EOF-controlled while statement:\ncin >> variable;  //initialize loop control variable\n\nwhile (cin) //test loop control variable\n{\n.\n.\n.\n  cin >> variable;  //update loop control variable\n.\n.\n.\n}\neof() function can determine end of file status\neof() function is member of data type istream--like other I/O functions (get, ignore, peek)\nSyntax of eof() function:\nistreamVar.eof()\n}\nistreamVar is input stream variable (e.g., cin)\nCode that reads integers until EOF or a non-int is encountered:\nint n;\nwhile (cin >> n)\n{\n  // do whatever appropriate with n, which is ensured to be of type int\n}\n// after all ints are read, execution picks up here\nThis works neatly, because operator >> returns zero when an error occurs, which would happen if a non-int or end-of-file is encountered.\n\n______________________________________________________________________________________________________________________________________________________________\n\nfor Loop\nUsing for Loop:\n\nExecutes a set number of times determined by the counter\nStatement can be a single statement or a compound (block) statement.\nfor is reserved word\nSimplifies writing of count-controlled while loop\nSyntax of for statement (for loop control statements):\nfor (initial statement; test statement (loop condition); update statement)\n     statement;\nExample:\n//printing 1 - 10 using for loop\ncout << \"for loop prints 1 - 10\" << endl;\nfor(int num=1; num < 11; ++num)\n  {\n    cout << num << endl;\n  }\nfor loop executes as follows:\nInitial statement executes (usually initializes variable)\nLoop condition evaluated. If loop condition evaluates to true...\nExecute for loop statement\nExecute update statement (last expression in parentheses)\nRepeat Step 2 until loop condition evaluates to false\nIf loop condition initially false, loop body does not execute\nUpdate expression, changes value of loop control variable (initialized by initial expression), eventually sets value of loop condition to false\nLoop body executes indefinitely if loop condition always true\nC++ allows fractional values for loop control variables of double type (or any real data type). However, different computers may give real data type loop control variables different results--use caution with such variables\n***Variable used in testing for loop has local scope!\nCan use same variable name in different for loops w/in same program--though, NOT recommended!\nSemicolon at end of for statement (just before body of loop) is semantic error--action of for loop is empty\nExample:\n for(int i = 1; i < 11; i++); //semantic error--action of for loop is empty\n    cout << i << endl;\nIn for statement, if loop condition omitted, assumed to be true\nIn for statement, can omit all three statements: initial statement, loop condition, and update statement. \"Legal,\" though infinite, for loop:\nExample:\nfor (;;)\n  cout << \"Hello\" << endl;\n\n________________________________________________________________________________________________________________________________________________________\n\n\ndo...while Loop\nUsing do...while Loop:\n\nExecutes at least once and up to many times depending on expression.\nSyntax of do...while statement:\ndo\n  statement\nwhile (expression);\nExample:\n//printing 1 - 10 using do while loop\ncout << \"do while loop prints 1 - 10\" << endl;\nint num1=1;\ndo \n  {\n    cout << num1 << endl;\n    num1=num1 + 1;\n  }\nwhile(num1 < 11); \ndo...while loop executes as follows:\nThe statement executes first, and then expression is evaluated\nIf expression evaluates to true, statement executes again\nAs long as expression in a do...while statement is true, statement executes\nLike other loops, to avoid an infinite loop, loop body must contain a statement that makes expression false\nStatement can be simple or compound (multiple statements); if compound, they must be in braces\n***REMEMBER, posttest loops (do...while) always iterate at least once (unlike for and while)\nbreak and continue Statements (alter flow of control)\n\n_____________________________________________________________________________________________________________________________________________________________\n\nUsing break Statements:\n\nWhen break statement executes in repetition structure, it immediately exits\nLikewise, break statement in switch structure provides an immediate exit\nbreak statement can be used in while, for, and do...while loops\nGenerally, break statement used for two purposes:\nTo exit early from loop\nTo skip remainder of switch structure\nAfter break statement executes, program continues with first statement after structure\nUse of break statement in loop can eliminate use of certain (flag) variables\nUsing continue Statements:\nWhen continue statement executes in repetition structure, skips remaining statements and proceeds with next iteration of loop\ncontinue statement can be used in while, for, and do...while structures\nIn while and do...while structure: expression (loop test) evaluated immediately after continue statement\nIn for structure: update statement executed after continue statement, then loop condition executes");
        setContent("                                    5. Repetition Structures\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j27ActionPerformed

    private void j28ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j28ActionPerformed
               jTextPane1.setText("What are Functions?\n\nIn general, we use (call) functions (aka: modules, methods, procedures, subprocedures, or subprograms) to perform a specific (atomic) task. In algebra, a function is defined as a rule or correspondence between values, called the function's arguments, and the unique value of the function associated with the arguments. For example:\n\nIf f(x) = 2x + 5, then f(1) =  7, f(2) =  9, and f(3) = 11\n\nYou would say the call f(1) returns the value 7\n\n1, 2, and 3 are arguments\n7, 9, and 11 are the resulting values (or corresponding values)\n\nBjarne Stroustrup's C++ Glossary\nC++ functions work in largely the same way. Format of a C++ function call:\n  functionName(argumentList)\nwhere the argumentList is a comma-separated list of arguments (data being sent into the function).\nIn general, function arguments may be constants, variables or more complex expressions.\nFunctions are building blocks\nAlso called modules, methods, procedures, or sub-procedures\nLike miniature programs\nCan be put together to form larger program\nOne of two principle means of modularization in C++ (other is classes)\nWhy use Functions?\nDivide and Conquer\nAllow complicated programs to be divided into manageable components\nProgrammer can focus on just the function: develop it, debug it, and test it\nVarious developers can work on different functions simultaneously\nReusability:\nCan be used in more than one place in a program--or in different programs\nAvoids repetition of code, thus simplifying code maintenance\nCan be called multiple times from anywhere in the program\nComponents:\nCustom functions and classes that you write\nPrepackaged functions and classes available in the C++ Standard Library\n\n\n_______________________________________________________________________________________________________________________________________________________________\n\nPredefined Functions\nUsing predefined functions:\n\nC++ Standard Library contains many predefined functions to perform various operations\nPredefined functions are organized into separate libraries\nI/O functions are in iostream header\nMath functions are in cmath header\nSome predefined C++ mathematical functions:\npow(x,y)\nsqrt(x)\nfloor(x)\nPower Function - pow(x,y):\nPower function pow(x,y) has two parameters\npow(x,y) returns value of type double\npow(x,y) calculates x to the power of y: pow(2,3) = 8.0\nx and y called parameters (or arguments) of function pow\nSquare Root Function - sqrt(x):\nSquare root function sqrt(x) has only one parameter\nsqrt(x) returns value of type double\nsqrt(x) calculates non-negative square root of x, for x >= 0.0: sqrt(2.25) = 1.5\nFloor Function - floor(x):\nFloor function floor(x) has only one parameter\nfloor(x) returns value of type double\nfloor(x) calculates largest whole number not greater than x: floor(48.79) = 48.0\n\n\n\n\n\n\n\nExample:\nIn general, function arguments may be constants, variables or more complex expressions\nThe pre-defined math function sqrt listed above takes one input value (of type double) and returns its square root. Sample calls:\n  double x = 9.0, y = 16.0, z;\n\n  z = sqrt(36.0); // sqrt returns 6.0 (gets stored in z)\n  z = sqrt(x);// sqrt returns 3.0 (gets stored in z)\n  z = sqrt(x + y);// sqrt returns 5.0 (gets stored in z) \n\n  cout << sqrt(100.0);// sqrt returns 10.0, which gets printed\n\n  cout << sqrt(49);     // because of automatic type conversion rules\n  //  we can send an int where a double is expected\n  //  this call returns 7.0\n\n  // in this last one, sqrt(625.0) returns 25.0, which gets sent as the\n  //  argument to the outer sqrt call.  This one returns 5.0, which gets\n  //  printed\n\n  cout << sqrt(sqrt(625.0));\n\n__________________________________________________________________________________________________________________________________________________________\n\nUser-Defined Functions\nUsing User-Defined functions:\n\nTwo types:\nVoid functions (nonvalue-returning): no return type, do not return a value\nValue-returning functions: have a data type, return only one value to caller\nWhen utilizing functions:\nInclude correct header file\nKnow function name\nKnow number of parameters, if any\nKnow data type of parameters\nKnow data type of value computed by function\nValue-returning function used 3 ways:\nAssignment statement\nOutput statement\nArgument (actual parameter) in another function call\nCreating functions:\n\nMnemonic: \"ProDeCall\":\nPrototype\nDefinition\nCall\nFunction prototype includes:\nFunction prototype: function heading without body of function\nTells the compiler the following:\nName of the function\nType of data it receives\nNumber of paramaters it expects\nType of paramters\nOrder of parameters\nWhile you don't HAVE to prototype, you SHOULD!\nWhy? Reduce program errors!\nCompiler correctly handles function return value\nCompiler checks you used correct number of function arguments\nCompiler checks you used correct type of arguments, if not, automatically type casts (numeric data types only)\nNOTE: Some compilers do these automatically, BUT it's best to be safe--prototype your functions!\nEasiest way to prototype?\nCopy function header and add a semi-colon (;)--however, don't need parameter names, only data types\nIf prototypes not used, then function must be defined before it is called, that is above main()--not good to do with large programs\nIf functions are defined before they are invoked, the definition serves as the prototype\n//function prototype syntax: only data types (not names) of parameters must be specified\nfunctionType functionName(formal parameter list);\nFunction signature:\nThe name of the function along with the types of its arguments is called the signature\nFunctions in the same scope must have unique signatures\nFunction definition includes:\nHeader (or heading) includes:\nFunction name\nNumber of parameters (if any)\nData type of each parameter\nType of function (data type or void)\nBody includes:\nCode to accomplish task\n***Any variables (if any) declared in body of function are local to function\nAll enclosed in braces {}\nFormal parameter (or parameter): variable declared in heading\nActual parameter (or argument): expressions, variables, or constant values listed in function call\n//Value-returning function definition syntax: including header and body\nfunctionType functionName(formal parameter list) //function header\n{\n   //function body\n   statements...\n\n   //value-returning function return statement\n   return expression;\n}\nFormal parameter list can be empty: parentheses still required\nFunction call includes:\nName with actual parameters (if any) in parentheses\nIn call statement, specify only arguments (actual parameters), not data types\nOne-to-one correspondence between actual and formal parameters (signature)\n\nMnemonic: \"TON\" - (must agree in Type, Order, and Number)\nValue-returning function called in an expression (only 3 ways):\nAssignment statement\nOutput statement\nArgument (actual parameter) in another function call\nFunction call results in execution of body of called function\n//function call syntax:\nx = functionName(actual parameter list); //Assignment, Output, Argument in another function call\nCall to value-returning function with empty formal parameter list:\nx = functionName(); //Assignment, Output, Argument in another function call\nAfter value-returning function is invoked, function returns value via return statement\n//return statement syntax:\nreturn expression;\nWhen return statement executes:\nFunction terminates\nControl goes back to caller\n***When return statement executes in function main(), program terminates\n\n_____________________________________________________________________________________________________________________________________________________________\n\nFlow of Execution\nProgram Execution:\n\nBegins with first statement in function main()\nAdditional functions invoked when called\nFunction prototypes appear before function definitions--that is, before function main()\nCompiler translates prototypes first\nFunction call invocation:\nTransfer of control to first statement in body of called function\nAfter function body executed: control passed back to point immediately following function call\nValue-returning function returns value\nAfter function execution: value that function returns replaces function call statement\n");
             setContent("                                    6. Functions 1 - Predefined and Value-Returning Functions\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j28ActionPerformed

    private void j29ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j29ActionPerformed
        jTextPane1.setText("Void (NonValue-Returning) functions:\n\nVoid functions are created and used just like value-returning functions except they do not return a value after the function executes. In lieu of a data type, void functions use the keyword \"void.\" A void function performs a task, and then control returns back to the caller--but, it does not return a value. You may or may not use the return statement, as there is no return value. Even without the return statement, control will return to the caller automatically at the end of the function. A good utilization of a void function would be to print a header/footer to a screen or file.\n\nRemember: there are two kinds of subprograms that the C++ language utilizes: value-returning functions and void functions. Both value-returning functions and void functions receive values through their parameter lists. A value-returning function can only return one value to the calling environment. The caller invokes (calls) a value-returning function by using its name and argument list in an expression (i.e., 1. assignment, 2. output, or as an 3. argument in another function call):\n\n//value-returning function call (assignment):\ny = 2.0 * sqrt(x);\nIn contrast, a void function (method or procedure, in other languages) does not return a function value. Nor is it called from within an expression. Instead, the function call appears as a complete, stand-alone statement. One example is the get function associated with the istream and ifstream classes:\n//void function call:\ncin.get();\nAnother example:\n//void function call:\nprintName(name);\nBjarne Stroustrup's C++ Glossary\nSimilarities Between Value-Returning and Void (NonValue-Returning) functions:\nBoth: require function definitions (i.e., headers and bodies)\nBoth: definitions can be placed before or after function main()...\nthough, if placed after main() function, prototypes must be placed before main()\nBoth: formal parameter list can be empty--though, parentheses still required\nBoth: actual parameter list can use expression or variable, but must match in \"TON\": type, order, number\nDifferences Between Value-Returning and Void (NonValue-Returning) functions:\nVoid function: does not have return type\nUses keyword void in function header\nCall to void function is stand-alone statement\n//Void (NonValue-returning) function definition syntax: including header and body\nvoid functionName(formal parameter list) //function header\n{\n   //function body\n   statements...\n\n   //void (nonvalue-returning) function can still use return statement\n   //but, does not return any values...\n   return;\n}\n\n//function call syntax:\nfunctionName(actual parameter list); //stand-alone statement only\nCall to void function with empty formal parameter list:\nfunctionName(); //stand-alone statement only\n***Void function calls can ONLY be used w/in stand-alone statements.\n\n***Conversely, value-returning function calls can be used in\noutput: e.g., cout statements\nassignment\narguments in other function calls\nFunction Parameters\nFunction Parameter Types:\nTwo Types of Function Parameters:\n\nValue Parameter: formal parameter receives copy of content of corresponding actual parameter\nReference Parameter: formal parameter receives location (memory address) of corresponding actual parameter\nUsing Value and Reference Parameters:\nValue Parameters:\nValue of corresponding actual parameter copied into formal parameter\nValue parameter has own copy of data\nDuring program execution, value parameter manipulates data stored in own memory space\nValue parameters will accept expressions, constants, or variables from actual parameters (i.e., in function call)\nVoid Function Definition Using Value Parameters Example:\n//Void (NonValue-returning) function definition syntax: including header and body\nvoid functionName(dataType variable, dataType variable) //function header\n{\n   //function body\n   statements...\n\n   //void (nonvalue-returning) function can still use return statement\n   //but, does not return any values...\n   return;\n}\n\n______________________________________________________________________________________________________________________________________________________________________________________\nReference Parameters:\nFormal parameter receives and stores address of corresponding actual parameter\nDuring program execution, address stored in reference parameter can modify data of corresponding actual parameter, by sharing same memory space\nReference parameters can: pass one or more values from function, and can change value of actual parameter\nReference parameters useful in three situations:\nReturning more than one value\nChanging value of actual parameter\nWhen passing address would save memory space and time\n***Reference parameter limitations: reference parameters will not accept expressions or constants from actual parameters (i.e., in function call), ONLY variables\nVoid Function Definition Using Reference Parameters Example:\n//Void (NonValue-returning) function definition syntax: including header and body\nvoid functionName(dataType& variable, dataType& variable) //function header\n{\n   //function body\n   statements...\n\n   //void (nonvalue-returning) function can still use return statement\n   //but, does not return any values...\n   return;\n}\nFunction Calls Using Value and Reference Parameter Examples:\nVoid function call using value parameters (can use expression, constant, or variable):\n//Void (NonValue-returning) function call with arguments \nfunctionName(expression or constant or variable, expression or constant or variable); //stand-alone statement only\nVoid function call using reference parameters (can NOT use expression or constant, ONLY variables):\n//Void (NonValue-returning) function call with arguments \nfunctionName(variable, variable); //stand-alone statement only\nFunction Parameters And Memory Allocation\nWhen a function is called:\n\nMemory for formal parameters (in header) and (local) variables declared in body of function allocated in function data area\nValue parameter: value of actual parameter copied into memory cell of its corresponding formal parameter\nReference parameter: address of actual parameter passed to formal parameter (content of formal parameter is an address)\nDuring execution, changes made by formal parameter permanently change value of actual parameter\nStream variables (e.g., ifstream and ofstream) should be passed by reference to function\nSummary of pass by value vs. pass by reference:\nPass by value:\nMakes copy of actual parameter\nPasses copy of contents\nOriginal variable's contents DO NOT change\nHow? Do nothing. Default.\nSafer\nPass by reference:\nPasses address of actual parameter\nAccesses original variable's contents (via address)\nOriginal variable's contents DO change\nHow? Add ampersand (&) before parameter name in header and prototype\nMore efficient\nNote: Although the C++ language allows value-returning functions to have both value parameters and reference parameters, it is not recommended. By definition, a value-returning function returns a single value; this value is returned via the return statement. Use void functions with reference parameters to return (modify) more than one value.\n\nProgram demos void functions using value and reference parameters:\n/*\nThis program demos void functions using\n  value parameters vs. reference parameters\n\nReference Parameter:\nIf a formal parameter is a reference parameter, it\nreceives the address of the corresponding actual\nparameter\n\nA reference parameter stores the address of the\ncorresponding actual parameter\n\nDuring program execution to manipulate the data,\nthe address stored in the reference parameter directs\nit to the memory space of the corresponding actual\nparameter\n*/\n\n//header files\n#include<iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n//prototype functions\nvoid readDate(int& month, int& day, int& year); //reference parameters\nvoid printDate(int month, int day, int year); //value parameters\n\n//initialize constants\n\n//initialize global variables\n\nint main()\n{\n  //initialize automatic variables\n  int mm, dd, yy;\n  readDate(mm, dd, yy);\n  printDate(mm, dd, yy);\n\n  cout << \"Press Enter key to exit...\";\n  cin.get(); cin.get(); // make DOS window stay open\n\n  return 0;\n}\n\n//function definitions\nvoid readDate(int& month, int& day, int& year)\n{\n  char ch; //local variable\n  cout << \"Enter a date (mm/dd/year): \";\n  cin >> month >> ch >> day >> ch >> year;\n}\n \nvoid printDate(int month, int day, int year)\n{\n  cout << \"The date is \" << month << '-' << day;\n  cout << '-' << year << endl;\n}\n\n____________________________________________________________________________________________________________________________________________________________________________________________________\nVoid or Value-Returning Functions?\nWhen to use Void or Value-Returning Functions:\n\nVoid Function: when must return more than one value or modify any of the caller's arguments\nVoid Function: when must perform I/O\nVoid Function: when in doubt, can recode any value-returning function as void function by adding additional outgoing parameter\nValue-returning Function: when only one value returned\nWhen/How to Pass/Return Values Recommendations:\nUse pass-by-value to pass very small objects (e.g., 3 ints, floats, doubles, etc.)\nUse pass-by-const-reference to pass large objects (that do NOT need to be modified)\nReturn result rather than modify object through reference argument (value-returning function)\nUse pass-by-reference ONLY when necessary\n\n\n___________________________________________________________________________________________________________________________________________________________________________________________________________\nScope\nWhat is scope?\n\nScope of an identifier refers to where in program an identifier is accessible\nLocal identifier: declared within a function (or block)\nGlobal identifier: declared outside of every function definition\nC++ does not allow nested functions (i.e., definition of one function cannot be included in body of another function)\nHowever, can call another function from within a function\nScope (accessibility) rules:\nGlobal identifier's (e.g., variables) accessibility within function (or block):\nIdentifier must be declared before function definition (block)\nScope of identifier declared outside of all namespaces, functions, and classes extends from point of declaration to end of file containing program code\nNames of function(s), parameter(s), and local identifier(s) must be different than global identifier (see exceptions below)\nException: global variable declared before definition of function (block) can be accessed by function (or block),\neven if function (or block) has an identifier with same name--by using scope resolution operator (::)\nException: C++ provides a way to access a global variable declared after definition of function--external variable. As a rule, functions should not contain any identifier with same name as global variable. Syntax for declaring external variable: extern int var;\nA global variable, that is a variable declared outside of all functions in a file, is accessible by any code in that file. By declaring extern variables, for programs that require multiple files, variables declared in one file can be accessible in other files. Variables that are declared as extern are often placed in an include file that is used by any file requiring access to the external variable. If there are multiple variables with the same name whose scopes overlap at one point in a program, the variable with the innermost scope will be used.\n\nAnother Exception: C++ allows function overloading, that is various functions with same name perform different operations (though, must have different parameters)\nFunction names have global scope\nLocal identifier's accessibility within function or nested block:\nAccessible from point of declaration to end of block, and...\nBy blocks nested within same function or block--provided that\nnames of additional identifier(s) are different than identifier outside of nested block(s)\nC++ allows the declaration of variables anywhere within a program, subject to the declare before use rule.\nC requires variable declarations at the beginning of a block. Here is code illustrating scope of three variables:\n\n                                //   scopes:\n                                //  x  i  j  k\nfloat x;                        //  |\nint main()                      //  |\n{                               //  |\n  int i;                        //  |  |\n  for (int j = 0; j < 100; ++j) //  |  |  |\n  {                             //  |  |  |\n    std::cin >> i;              //  |  |  |\n    int k = i;                  //  |  |  |  |\n    // more code                //  |  |  |  |\n  }                             //  |  |\n  return 0;                     //  |  |\n}                               //  |\n\n\nNote that x is global, i and j are local. The following code is more subtle.\n\n#include <iostream>\nint main()\n{\n  std::cout << \"\\nStarting Program\\n\";\n  {\n    int x = 5;// declare new variable\n    std::cout << \"x = \" << x << '\\n';\n    {\n      int x = 8;\n      std::cout << \"x = \" << x << '\\n';\n    }\n    std::cout << \"x = \" << x << '\\n';\n    {\n      x = 3;\n    }\n    std::cout << \"x = \" << x << '\\n';\n  }\n}\n\nYou can run the program to be sure you understand how scope rules affect the\nvalues of the variables. \n\n_______________________________________________________________________________________________________________________________________________________________________________________________\nNamespace Scope:\nScope of identifier declared in namespace definition extends from point of declaration to end of namespace body\nIdentifier's scope includes scope of using directive specifying that namespace\n3 Ways to Implement Namespace Identifiers:\nQualified name: namespace, scope resolution operator (::) and identifier\n  std::cout << \"Namespace test\";\nUsing declaration:\n  using std::cout;\n  cout << \"Namespace test\";\nUsing directive (local or global):\n  using namespace std;\n  cout << \"Namespace test\";\nGlobal variable problems:\nBecause of global variable's accessibility:\nCan cause \"dependency\" issues in other parts of program (e.g., identifier names)\nDifficult to debug problems\nMake unit testing difficult (isolated units of code)\nMake it difficult to \"decentralize\" software into modules or components\nSince global variables are shared by different modules, they make each of these modules more difficult to understand separately, diminishing readability and hence hampering maintenance.\nAs global variables constitute a form of undercover dependency between modules, they are a major obstacle to software evolution, since they make it harder to modify a module without impacting others.\nThey are a major source of nasty errors. Through a global variable, an error in a module may propagate to many others. As a result, the manifestation of the error may be quite remote from its cause in the software architecture, making it very hard to trace down errors and correct them. This problem is particularly serious in environments where incorrect array references may pollute other data.\nThere is also another problem, less fundamental but still annoying: since a global variable does not belong to any one module in particular, it is not clear where it should be initialized.\nGlobal Variables\nScope Summary Rules:\nFunction names have global scope\nFunction parameter's scope is identical to scope of local variable declared in outermost block of function body\nGlobal variable's (or constant's) scope extends from its declaration to end of program file, except as noted in rule 5\nLocal variable's (or constant's) scope extends from its declaration to end of block where declared, including any nested blocks, except as noted in rule 5\nIdentifier's scope does not include any nested block that contains a locally declared identifier with same name (local identifiers have name precedence)\n\n______________________________________________________________________________________________________________________________________________________________________________________\nLifetime\nWhat is lifetime?\n\nIdentifier lifetime: time during program execution in which identifier stored in memory\nAutomatic variable:\nKeyword auto\nMemory allocated at block entry and deallocated at block exit\nLocal variables are automatic storage class by default so auto seldom used\nVariables declared within a block are automatic variables\nStatic variable:\nMemory remains allocated as long as program executes\nVariables declared outside any block are static (and global) variables\nStatic variables declared within block are local to block\nScope of static variable same as other local identifiers of that block\nCan also declare static variable within block by using reserved word static\nSyntax for declaring static variable:\n  static dataType identifier;\n\n  static int x; //static variable of type int\nStub Functions\nUsing Stub Functions:\n\nStub functions may be used when testing programs. A stub function is a stripped-down, skeletal structure of the actual function. It does not implement the full details of the algorithm or function requirements. It does contain the parameter lists. Essentially, a stub is a dummy function with a limited body, usually just output statements that acknowledge the function was reached, and a return value (if any) of the correct type. Usually, the stub function's name and parameter list is the same as the function that will actually be called by the program being tested.\n\n________________________________________________________________________________________________________________________________________________________________________________\nFunction Overloading\nWhat is Function Overloading:\n\nSeveral functions with the same name is called function overloading. Generally, function overloading is used when different data types will be used with the same function. As an illustration, one function may accept integer values, while another can receive char or float data. Of course, you could implement the same functionality using a different function name whose parameters would receive the various data types--or, you can employ function overloading.\n\nWhen overloading a function, dissimilar signatures (i.e., different \"TON\": type, order, or number) must be used for each overloaded version. A function signature consists of a list of data types of its parameters, as well as their order, and number (i.e., the number of parameters).\n\nLastly, a function differing only by return type, OR different parameter names is illegal (though, it is legal to use a different return type with a different parameter list--that is, different \"TON.\" See below):\n\nFunction Overloading Example:\n//valid overloaded function prototypes (applicable to definitions as well)...\nvoid myFunc();\nvoid myFunc(int i);\nvoid myFunc(char c);\nvoid myFunc(char c, int i);\nvoid myFunc(int i, char c);\nvoid myFunc(string & s);\n\n//Error: differs from void myFunc(); only by return type\nint myFunc();\n\n//OK: Different \"TON\" (i.e., unique signature)\nint myFunc(float f);\n\n/*\nThe functions myFunc, using the same number of parameters (two, with\njust different names), and the same data\ntypes (int and char), in the same order, have the same formal\nparameter list, and, is therefore illegal...\n*/\nvoid myFunc(int myInt, char myChar); //illegal--same \"TON\"\nFunction Overloading Summary:\nFunction overloading: create several functions with same name\nFunction signature: function name and its formal parameter list\nTwo functions using different signatures: different names or different formal parameter lists (i.e., different \"TON\")\nNote: different function signatures do not include different return types, or different parameter names\n\n___________________________________________________________________________________________________________________________________________________________________\nFunctions with Default Parameters\nUsing Functions with Default Parameters:\n\nWhen a function is called, the number of actual and formal parameters must be the same except in the case of default parameters. The value of a default parameter is specified when the function name appears for the first time (as in the prototype).\n\nThe following rules apply to default parameters:\n\nSpecify default parameter values when function name appears for first time (as in the prototype)\nIf no default parameter value is specified, the default value is used\nAll default parameters must be the rightmost parameters of function\nIn function call where function has more than one default parameter, and a value to a default parameter is not specified, must omit all of arguments to its right\nDefault values can be constants, global variables, or function calls\nCaller has option of specifying a value other than the default for any default parameter\nCannot assign constant value as default value to reference parameter\nFunctions with Default Parameters Example:\n//function prototype...applies to definitions as well...\nvoid myFunc(int x, int y, double t, char z = 'A', int u = 50, \nchar v='B', double w = 18.56);\n\n//local variables\nint a, b;\nchar ch;\ndouble d;\n\n//legal function calls\nmyFunc(a, b, d);\nmyFunc(a, 15, 36.1, 'C', 92, ch);\nmyFunc(b, a, 13.21, 'D');\n\n//illegal function calls\nmyFunc(a, 15, 33.1, 62.3);\nmyFunc(b, 25, 32.9, 'E', 1234, 92.7);\n\n___________________________________________________________________________________________________________________________________________________________________\nRecursion\nA Recursive Function:\n\nCalls itself\nKnows how to solve the simplest case(s), or base case(s)\nIf the function is called with a base case it simply returns the result without recursion\nTo terminate, the sequence of recursive calls must converge on the base case.\nSimilarities between Recursion & Iteration:\nBoth: are based on a control statment\nBoth: involve repetition\nBoth: involve a termination test\nBoth: gradually approach termination\nBoth: can result in an infinite loop\nDrawbacks for Recursion:\nRepeatedly overhead of function calls\nCan be expensive in both processor time and memory space\nEach call creates another set of the functions variables\n");
         setContent("                                    7. Functions 2 - Void (NonValue-Returning) Functions\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j29ActionPerformed

    private void j30ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j30ActionPerformed
        jTextPane1.setText("UDTs (User-Defined Types), Namespaces, and string Type\nUDTs (User-Defined Types):\n\nA data type is a set of values together with a set of operations on those values. User-defined types are collections of data, which describe an object's attributes and state. In C++, there are many examples of objects, including user-defined variables. Every object has a type, like variables of native types (short, char, float, etc.). For example, a class can be defined called MyClass, then objects can be instantiated of type MyClass, like native variables can be of type short, char, etc. However, since the compiler has no fundamental understanding of user-defined types, programmers have to define these data types.\n\nUser-Defined Types\n\nClasses\nEnumerations\ntypedef definitions\nStructures (or records)\nClasses\nClass: Review Chapter 9 of the text book for a more detailed review of classes.\n\nA class specified by the keyword class, is a user defined type that contains both data members and member functions...\n\n_______________________________________________________________________________________________________________________________________________________\nModularity:\nBreaking a program into modules reduces complexity\nDifferent modules allows different individuals or teams of individuals to work on separate components without interference\nMakes code blocks available for re-use\nClasses (and Functions) provide a means of modularization in C++\nEncapsulates data; limits the scope of data variables\nProtects data from outside manipulation\nLimit scope of functionality by providing class methods\nSpecialize functionality to the particular data and intended use of the class\nA class definition begins with the keyword class followed by the class name.\nBy convention, the name of a user-defined class begins with a capital letter.\nEach subsequent word in the class name begins with a capital letter.\nclass GradeBook\nThe class body\nis enclosed within a pair of braces ( { and } )\nends with a semicolon\nMember functions\nCan be called by other functions in a program and by member functions of other classes if declared within the public section\nThe function body is enclosed within a pair of braces ( { and } )\nConstructors\nMust be defined with the same name as the class\nGradeBook ( string );\nSimilar to functions but cannot return values so they cannot specify a return value (not even void)\nThe constructor is called each time an object is created ensuring it is properly initialized before use\nInitialize the object variables within the constructor body\nA constructor with no parameters is default constructor\nIf a constructor is not provided, the compiler provides a default constructor\nIf you define a constructor the compiler will not create a default constructor, so if the default constructor is needed it must be defined explicitly.\nAn Object is an instance of a class\nTo use an object:\n1. Define the class\nclass GradeBook\n{\n...\n};\n2. Implement the member functions of the class\nvoid displayMessage()\n{\n...\n}\n3. Create the object (by declaring a variable)\nGradeBook myGradeBook;\n4. Call the function using dot '.' notation.\nmyGradeBook.displayMessage();\nSimple Class Example:\nTo define and declare a class within one file. The following is an example only and is not a practical use of a class.\n(The section beginning with Reusability demonstrates how to separate the header file and source code)\n// Fig. 3.1: fig03_01.cpp\n// Define class GradeBook with a member function displayMessage;\n// Create a GradeBook object and call its displayMessage function.\n#include <iostream>\nusing namespace std;\n\n// GradeBook class definition\nclass GradeBook\n{\npublic:\n   // function that displays a welcome message to the GradeBook user\n   void displayMessage()\n   {\n      cout << \"Welcome to the Grade Book!\" << endl;\n   } // end function displayMessage\n}; // end class GradeBook  \n\n// function main begins program execution\nint main()\n{\n   GradeBook myGradeBook; // create a GradeBook object named myGradeBook\n   myGradeBook.displayMessage(); // call object's displayMessage function\n} // end main\n\n__________________________________________________________________________________________________________________________________________________________________\nReusability:\nHaving main() in the same file as the class definition prevents reuse\nSeparate the class and main()\nSeparate the interface (.h) from implementation (.cpp)\nMakes programs easier to modify\nThe client interface should not have to change if the implementation changes\nThe interface (.h) contains the prototypes or definitions\nThe implementation (.cpp) contains the source code\nHeader File\nDescribes the class public interface without revealing the implementations\nIncluded (#include) into client (.cpp) programs\nMember functions are normally declared public and can be called by other functions in a program and by member functions of other classes\nSet() and Get() functions allow clients of a class to access the private data members\nAn empty set of parenthesis after a function name indicates that the function does not require addtional parameters to perform it's task.\nstring getCourseName()\nA parameter list within the parenthesis indicates one or more parameters are required.\nvoid setCourseName( string )\nData members are normally declared private and accessible only to member functions\n// Fig. 3.11: GradeBook.h\n// GradeBook class definition. This file presents GradeBook's public \n// interface without revealing the implementations of GradeBook's member\n// functions, which are defined in GradeBook.cpp.\n#include <string> // class GradeBook uses C++ standard string class\nusing namespace std;\n\n// GradeBook class definition\nclass GradeBook\n{\npublic:\n   GradeBook( string ); // constructor that initializes courseName\n   void setCourseName( string ); // function that sets the course name\n   string getCourseName(); // function that gets the course name\n   void displayMessage(); // function that displays a welcome message\nprivate:\n   string courseName; // course name for this GradeBook\n}; // end class GradeBook\nSource Code\nEach member function name from the header file is preceded by the class name and ::, known as the scope resolution operator\nThe number and type of arguments in the function call must match the number of parameters in the parameter list.\n// Fig. 3.12: GradeBook.cpp\n// GradeBook member-function definitions. This file contains\n// implementations of the member functions prototyped in GradeBook.h.\n#include <iostream>\n#include \"GradeBook.h\" // include definition of class GradeBook\nusing namespace std;\n\n// constructor initializes courseName with string supplied as argument\nGradeBook::GradeBook( string name )\n{\n   setCourseName( name ); // call set function to initialize courseName\n} // end GradeBook constructor\n\n// function to set the course name\nvoid GradeBook::setCourseName( string name )\n{\n   courseName = name; // store the course name in the object\n} // end function setCourseName\n\n// function to get the course name\nstring GradeBook::getCourseName()\n{\n   return courseName; // return object's courseName\n} // end function getCourseName\n\n// display a welcome message to the GradeBook user\nvoid GradeBook::displayMessage()\n{\n   // call getCourseName to get the courseName\n   cout << \"Welcome to the grade book for\\n\" << getCourseName() \n      << \"!\" << endl;\n} // end function displayMessage\nDriver Program\nContains main()\n/ Fig. 3.13: fig03_13.cpp\n// GradeBook class demonstration after separating \n// its interface from its implementation.\n#include <iostream>\n#include \"GradeBook.h\" // include definition of class GradeBook\nusing namespace std;\n\n// function main begins program execution\nint main()\n{\n   // create two GradeBook objects\n   GradeBook gradeBook1( \"CS101 Introduction to C++ Programming\" );\n   GradeBook gradeBook2( \"CS102 Data Structures in C++\" );\n\n   // display initial value of courseName for each GradeBook\n   cout << \"gradeBook1 created for course: \" << gradeBook1.getCourseName()\n      << \"\\ngradeBook2 created for course: \" << gradeBook2.getCourseName() \n      << endl;\n} // end main\n\n\n________________________________________________________________________________________________________________________________________________________________________________________________________\nEnumeration Data Type\nEnumeration Data Type:\n\nAn enumeration, specified by the keyword enum, is a set of integer constants associated by identifiers--called enumerators. Enumerations provide a manner to implement names (or identifiers), in place of integer constants. Enumerator values begin at zero (0), if a value for the initial enumerator was not provided. Enumerators may be used wherever an int value is utilized. If no user specified value is assigned, compilers will assign the following integer value after the integer value assigned to the preceding enumerator.\n\nUsing Enumeration Data Type:\nTo define enumeration data type:\nName for data type\nValues for data type\nOperations on values (C++ does not allow users to create operations for enumeration type)\nCreating Enumeration Data Type:\nValues for data type must be identifiers, called enumerators\nEnumeration type is an ordered set of values specified between braces\nDefault value assigned to enumerators begins at 0, and continues as 1, 2, ... (other values can be assigned)\nSyntax for enumeration type:\nenum typeName {value1, value2 ...}; //indentifiers value1 and value2 called enumerators\nIf value used in one enumeration type, cannot be used by any other enumeration type in same block,\nas well as enumeration types declared outside of any blocks (global)\nenum csStudent {Bill, Jen, Steve, Larry};\nenum mathStudent {Mary, Doug, Jen, Clay}; //illegal, value Jen can't be used in same program, in same block\n\n\n__________________________________________________________________________________________________________________________________________________________________\nDeclaring Variables:\nWhen data type defined, variables of that type can be declared\n//defines vehicle as an enumeration type, with values: auto, truck, motorcycle, snowmobile, and boat\nenum vehicle {auto, truck, motorcycle, snowmobile, boat};\nvehicle myVehicle; //variable of type vehicle declared\nvehicle yourVehicle; //another variable of type vehicle declared\nValues must use legal C++ identifier names:\nenum vehicle {\"auto\", \"truck\", ...}; //illegal, can't use quotes\nenum number {1, 2, 3}; //illegal, can't begin identifier name with number\nenum number {one, two, three}; //legal value\n\n___________________________________________________________________________________________________________________________________________________________________________________\nAssignment:\nWhen variable declared, values can be stored in variable:\nvehicle myVehicle, yourVehicle; //variables of type vehicle declared\nmyVehicle = Car; //assigns Car to myVehicle \nyourVehicle = myVehicle; //copies contents of variable myVehicle into yourVehicle\n\n//Or...\n//Creating enumeration type, and declaring variables of that type in one step:\nenum vehicle {auto, truck, motorcycle, snowmobile, boat} myVehicle, yourVehicle;\n\n__________________________________________________________________________________________________________________________________________________________________\nOperations:\nNo arithmetic, or increment and decrement operations allowed on enumeration types:\nyourVehicle = myVehicle + 2; //illegal:\ntheirVehicle = myVehicle + yourVehicle; //illegal:\nmyVehicle++; //illegal:\nmyVehicle--; //illegal:\nCan use cast operator:\nyourVehicle = static_cast<vehicle>(yourVehicle + 1);\nOperations and Input/Output:\nBecause an enumeration is an ordered set of values\nCan use relational operators\nCast operator can be used to increment, decrement, and compare values\nValues can be used in loops\nInput and output defined only for built-in data types such as int, char, double\nEnumeration type can be neither input nor output (directly)\nFunctions and Enumeration Types:\nEnumeration type can be passed as parameters to functions either by value or by reference\nFunction can return value of enumeration type\nAnonymous Data Types:\nValues directly specified in variable declaration with no type name:\n//Creating anonymous enumeration data type, and declaring variables of that type in one step:\nenum {auto, truck, motorcycle, snowmobile, boat} myVehicle, yourVehicle;\nAnonymous Data Type Issues:\nCannot pass anonymous data type as parameter to function\nFunction cannot return value of anonymous type\nValues used in one can be used in another, but are treated differently\nSummary of enumeration type:\nEnumeration type is set of ordered values\nReserved word enum creates enumeration type\nNo arithmetic operations allowed on enumeration type\nRelational operators can be used with enum values\nEnumeration type values cannot be input or output directly\nAnonymous type: variable's values specified without any type name\n//This program demos enumeration data types\n\n#include <iostream>\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n//initialize constants\n\n//initialize global variables\n\n//prototype functions\n\nint main()\n{\n  //initialize local variables\n\n  enum bookType {Math, CSC, English, History, Physics, Philosophy};\n\n  bookType book;\n\n  book = English;\n  cout<<\"book = \"<< book <<\" (ONLY outputs DEFAULT value DIRECTLY.)\" << endl;\n\n  book = static_cast<bookType>(book + 1);\n  cout<<\"book = \"<< book <<\" (increment, still ONLY outputs DEFAULT value DIRECTLY.)\" << endl;\n\n  //must decrement for next block of code to work properly...\n  book = static_cast<bookType>(book - 1);\n  \n  cout<<\"The enumeration value currently selected is \";\n\n  switch (book)\n    {\n    case Math:  cout << \"Math\";\n      break;\n    case CSC:  cout << \"CSC\";\n      break;\n    case English: cout << \"English\";\n      break;\n    case History: cout << \"History\";\n      break;\n    case Physics: cout << \"Physics\";\n      break;\n    case Philosophy: cout << \"Philosophy\";\n    }\n\n  cout << \"\\nPress Enter key to exit...\";\n  cin.get();  // make DOS window stay open, sometimes...\n\n  return 0;\n}\nSample Run:\nbook = 2 (ONLY outputs DEFAULT value DIRECTLY.)\nbook = 3 (increment, still ONLY outputs DEFAULT value DIRECTLY.)\nThe enumeration value currently selected is English\nPress Enter key to exit...\nEnumeration Program\n\n______________________________________________________________________________________________________________________________________________________________________________________________________________\ntypedef Statement\nUsing typedef Statement:\n\nAs a shortcut to long, repetitious variable declarations, and as an error preventative measure, C++ allows the creation of an alias or synonym--by using the keyword typedef, which stands for type definition. Type definitions are also useful when data types may change in later revisions of programs. With a type definition, a synonym or alias is created. Realize that typedef does not create a new type--it is important to understand the distinction. The syntax for a type definition is typedef, followed by the existing type, then the alias or synonym, ending with a semicolon. For example:\n\n//typedef defined...\n//USHORT synonym for unsigned short int\ntypedef unsigned short int USHORT;\nThe typedef definition creates an alias or synonym called USHORT that can be used rather than unsigned short int:\n//data type of weight is unsigned short int\nUSHORT weight = 160;\nSummary of typedef Definitions:\nC++ allows synonyms or aliases based upon existing data types, by using typedef statement\ntypedef does not create any new data types\ntypedef creates alias to existing data type\nCan create synonyms or aliases to previously defined data types by using typedef statement\nANSI/ISO Standard C++\nANSI/ISO Standard C++:\n\nANSI/ISO standard C++ was officially approved in July 1998.\n\nMost compilers compatible with ANSI/ISO standard C++\nStandard C++ and ANSI/ISO standard C++ are \"mostly\" the same, but...\nANSI/ISO Standard C++ has some features not available in Standard C++\n_____________________________________________________________________________________________________________________________________________________________________________________________________________________\nNamespaces\nUsing Namespaces:\n\nANSI/ISO Standard C++ has some features not available in Standard C++. ANSI/ISO Standard C++ (July, 1998) included the namespace mechanism--Standard C++ did not have it. For example, when a header file, such as iostream, is included in a program, global identifiers in the header file also become global identifiers in the program. If a global identifier in a program has the same name as one of the global identifiers in the header file, the compiler will generate a syntax error (such as identifier redefined). The same problem can occur if a program uses libraries from other compiler vendors. To overcome this problem, these third party compiler vendors usually begin their global identifiers with a special symbol--for example, an underscore character (_). To avoid problems associated with identifier conflicts and linking errors, it is a good policy not to begin identifier names with the underscore character (_) even though it is permissable. ANSI/ISO standard C++ uses namespaces to assist with the problem of overlapping global identifier names.\n\nANSI/ISO Standard C++ resolves the problem of overlapping global identifier names with the namespace mechanism.\n\nThe scope of a namespace member is local to the namespace. Though, a namespace member can be accessed outside the namespace in one of three ways:\n\nEach time it is accessed:\n1) namespace_name::identifier\n\nSimplified (place using statement after the namespace declaration):\n2) using namespace namespace_name (access all namespace members)\n3) using namespace namespace_name::identifier (access specific namespace member)\nAfter the using statement, you do not have to put the namespace_name and the scope resolution operator before the namespace member to access a namespace member.\nSyntax of namespace Statement:\nnamespace namespace_name\n{\n  members...\n}\nMember is usually named constant, variable declaration, function, or another namespace\nScope of namespace member is local to namespace,\nbut can be accessed outside of namespace by using scope resolution operator (::)\nNamespace Example:\nnamespace myNamespace\n{\n  const double PI=3.14;\n  int count=0;\n  void printReport();\n}\nDefines namespace myNamespace with three members: named constant PI, variable count, and void function printReport().\nAccessing namespace Member:\nScope of namespace member is local to namespace\n3 Ways to access namespace members:\nQualified name: namespace, scope resolution operator (::) and identifier\n    //To access each namespace member:\n    myVar = myNamespace::PI;\n    myVar = myNamespace::count;\n    myNamespace::printReport();\n  \nUsing declaration:\n    //Simplify accessing specific namespace member:\n    using myNamespace::PI;\n    myVar = PI;\n  \nUsing directive (local or global):\n    //Simplify accessing all namespace members:\n    using namespace myNamespace;\n    myVar = count;\n  \n____________________________________________________________________________________________________________________________________________________________________________________________\nUsing using Statement:\nThe keyword namespace must appear in using statement\nNot necessary to precede namespace_name and scope resolution operator before namespace member\nIf namespace member and global identifier or block identifier have same name, namespace_name and scope resolution operator must precede namespace member\nstring Data Type\nUsing string Data Type:\n\nString is sequence of zero or more characters\nIn C++, strings enclosed in double quotation marks\nTo use data type string, program must include header file <string>\nstring data type example:\n  string name = \"John Doe\";\n  \nDeclares name as string variable, and initializes name to \"John Doe\"\nFirst character, 'J', in position 0, second character, 'o', in position 1, etc.\nData type string may use binary operator (+) for string concatenation, and array subscript operator [], for character arrays\nIn C++, [] called array subscript operator\nString concatenation example:\n  string str1 = \"Hi\";\n  string str2;\n  str2=str1 + \" there!\";\n  //str2 contains \"Hi there!\"\n  \nlength() Function:\nLength returns number of characters in string\nlength() function uses no arguments\nlength() returns unsigned (non-negative) integer\nValue returned can be stored in integer variable\nSyntax to call length function (myStr of type string):\n  myStr.length();\n  \nExample:\nstring firstName;\nstring name;\nstring str;\n\nfirstName = \"John\";\nname = firstName + \" Doe\";\nstr = \"Hello World.\";\n\ncout << firstName.length() << endl; //prints 4\ncout << name.length() << endl; //prints 8\ncout << str.length() << endl; //prints 12\nsize() Function:\nsize() function similar to length() function (returns number of characters in string)\nBoth functions return same value\nlike length() function, size() function uses no arguments\nsize() returns unsigned (non-negative) integer\nValue returned can be stored in integer variable\nSyntax to call size() function (myStr of type string):\n  myStr.size();\n  \nfind() Function:\nfind() function searches string for first occurrence of substring\nReturns unsigned (non-negative) integer value of type string::size_type\nSyntax to call find() function (myStr of type string, and strExp is string expression or character):\n  myStr.find(strExp);\n  \nSuccessful search returns position in myStr where match begins (must be exact)\nUnsuccessful search returns value string::npos (\"not a position within the string\")\nExample:\nstring str = \"It is sunny, isn't it?\";\n\ncout << str.find(\"is\") << endl; //prints 3\ncout << str.find(\"s\") << endl; //prints 4\ncout << str.find(\"it\") << endl; //prints 19\nsubstr() Function:\nsubstr() function returns a specific substring of a string\nSyntax to call substr() function (myStr of type string):\n  myStr.substr(strExp1,strExp2);\n  \nstrExp1 and strExp2 are expressions evaluating to unsigned (non-negative) integers\nExpression strExp1 specifies starting position of substring\nExpression strExp2 specifies length of substring to be returned\nExample:\nstring str = \"It is sunny, isn't it?\";\n\ncout << str.substr(0, 5) << endl; //prints It is\ncout << str.substr(6, 5) << endl; //prints sunny\ncout << str.substr(3, 2) << endl; //prints is\nswap() Function:\nswap() function swaps (interchanges) contents of two string variables\nSyntax to call swap() function (myStr1 and myStr2 of type string):\n  myStr1.swap(myStr2);\n  \nswap() function example:\n  //string initialization\n  string myStr1 = \"Stop\";\n  string myStr2 = \"Go\";\n\n  myStr1.swap(myStr2);\n  \nAfter myStr1.swap(myStr2); executes, value of myStr1 is \"Go\" and value of myStr2 is \"Stop\"\n");
        setContent("                                    8. UDTs (User-Defined Types), Namespaces, and string Type\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j30ActionPerformed

    private void j31ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j31ActionPerformed
                jTextPane1.setText("Data Types, Arrays and Strings\nSimple and Structured Data Types:\n\nA simple data type can store only one value at a time. A structured data type is one in which each data item is a collection of other data items. In a structured data type, the entire collection uses a single identifier (name). The purpose of structured data types is to group related data of various types for convenient access using the same identifier. Similarly, data can then be retrieved as an aggregate, or each component (element) in the collection can be accessed individually. Furthermore, a structured data type is a user-defined data type (UDT) with elements that are are divisible, and can be used discretely or as a single unit, as appropriate.\n\nC++ simple data types:\n\nintegral (char, short, int, long, and bool)\nenum\nfloating (float, double, long double)\nC++ structured data types:\narray\nstruct\nunion\nclass\n***Even though individual characters in a string can be accessed, the string data type is not considered a structured data type.\n\n________________________________________________________________________________________________________________________________________________________________________________\nArrays\nDescription:\n\nArray: collection of fixed number of components (elements), wherein all of components have same data type\nOne-dimensional array: array in which components are arranged in list form\nMulti-dimensional array: array in which components are arranged in tabular form (not covered)\nArray Basics:\nConsecutive group of memory locations that all have the same type\nThe collection of data is indexed, or numbered, and at starts at 0\nPosition number is formally called the subscript or index\nFirst element is subscript 0 (zero), sometimes called the zeroth element.\nThe highest element index is one less than the total number of elements in the array\nDeclaring Arrays:\nSyntax to declare one-dimensional array:\n\n//intExp evaluates to positive integer--indicates number of elements \n dataType arrayName[intExp];\n\n//declares array num containing 5 elements of type int:\n//num[0], num[1], num[2], num[3], and num[4]\nint num[5]; \nIndex (intExp), any expression whose value is non-negative integer\nintExp indicates number of elements\nSize of array: number of elements\nCompiler reserves the appropriate amount of memory\nInitializing Arrays:\nAccessing Array Elements:\nSyntax to access array element:\n\n  //Index value (intExp) specifies position of element in array\n  arrayName[intExp]\n\n  //fifth element in array num\n  num[4]; \nIndex (intExp), any expression whose value is non-negative integer\nSpecific index value (e.g., num[0]) indicates position of element in array\nPosition number: distance from 1st element of array, beginning at 0 (zero)\nIndex value indicates position of element in array\nArray subscripting operator []\nArray index always begins at 0\n\n  //declare array item with five elements of type int\n  int item[5];\n\n  //assign value 35 to 5th element in item array\n  item[4]=35;\n\n  //assign value 10 to 4th element in item array\n  item[3]=10;\n\n  //assign value 45 to 3rd element in item array\n  item[2]=item[3] + item[4];\nProcessing One-Dimensional Arrays (basic array operations using iteration):\nInitialize\nInput\nOutput\nSum and Average\nFind largest element value\nFind smallest element value\n\n  //initialize named constant\n  const int arraySize=5;\n\n  //declare array list with arraySize elements of type double \n  double list[arraySize];\n\n  //initialize 7 variables\n  int i=0;\n  double smallest=0.0;\n  double largest=0.0;\n  double sum=0.0;\n  double average=0.0;\n  int maxi=0;\n  int mini=0;\n\n  //1. initialize each element in array list to 0.0, beginning w/first element\n  for (i=0; i < arraySize; i++)\n    list[i]=0.0;\n\n  //2. input value for each element in array list, beginning w/first element\n  for (i=0; i < arraySize; i++)\n    cin >> list[i];\n\n  //3. output value for each element in array list, beginning w/first element\n  for (i=0; i < arraySize; i++)\n    cout << list[i] << \" \";\n\n  //4. sum and average elements in array list, and display\n  for (i=0; i < arraySize; i++)\n    sum = sum + list[i];\n    average = sum / arraySize;\n\n    cout << \"Sum = \" << sum;\n    cout << \"\\nAverage = \" << average;\n\n  //5. find largest element value in array list, and display\n  for (i=0; i < arraySize; i++)\n      if (list[maxi] < list[i])\n\t maxi = i;\n      largest = list[maxi];\n      \n    cout << \"\\nLargest = \" << largest;\n\n  //6. find smallest element value in array list, and display\n  for (i=0; i < arraySize; i++)\n      if (list[mini] > list[i])\n\t    mini = i;\n\tsmallest = list[mini];\n  \n    cout << \"\\nSmallest = \" << smallest;\n \nArray Index Out of Bounds\n\n  //declare array with 10 elements of type double\n  double num[10];\n\n  //declare index variable\n  int i;\nIndex out of bounds: no implicit safeguard; programmer must protect against indices out of bounds\nElement num[i] valid index only if i = 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9\nIndex of array within bounds: index >=0 AND index <=ARRAY_SIZE - 1\nindex out of bounds: index < 0 OR index > ARRAY_SIZE - 1\n***Index value must always be less than size of array\nArray Initialization\nLike simple variables, arrays can be initialized during declaration\nWhen initializing arrays, not required to specify size of array\nSize of array determined by number of values within braces\n\ndouble sales[] = {12.25, 32.50, 16.90, 23, 45.68};\n\n//same result as...\ndouble sales[5] = {12.25, 32.50, 16.90, 23, 45.68};\nUsing a loop\n\n// Fig. 7.3: fig07_03.cpp\n// Initializing an array's elements to zeros and printing the array.\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main()\n{\n   int n[ 10 ]; // n is an array of 10 integers\n\n   // initialize elements of array n to 0\n   for ( int i = 0; i < 10; ++i )        \n      n[ i ] = 0; // set element at location i to 0\n\n   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n\n   // output each array element's value\n   for ( int j = 0; j < 10; ++j )        \n      cout << setw( 7 ) << j << setw( 13 ) << n[ j ] << endl;\n} // end main\n\nUsing an Initializer List\n// Fig. 7.4: fig07_04.cpp\n// Initializing an array in a declaration.\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nint main()\n{\n   // use initializer list to initialize array n\n   int n[ 10 ] = { 32, 27, 64, 18, 95, 14, 90, 70, 60, 37 };\n   \n   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n\n   // output each array element's value\n   for ( int i = 0; i < 10; ++i )\n      cout << setw( 7 ) << i << setw( 13 ) << n[ i ] << endl;\n} // end main\nSpecifying Array Size with Constant and Setting Array Elements with Calculations\n// Fig. 7.5: fig07_05.cpp\n// Set array s to the even integers from 2 to 20.\n#include \n#include \nusing namespace std;\n\nint main()\n{\n   // constant variable can be used to specify array size\n   const int arraySize = 10; // must initialize in declaration\n   \n   int s[ arraySize ]; // array s has 10 elements\n\n   for ( int i = 0; i < arraySize; ++i ) // set the values\n      s[ i ] = 2 + 2 * i;\n\n   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n\n   // output contents of array s in tabular format\n   for ( int j = 0; j < arraySize; ++j )   \n      cout << setw( 7 ) << j << setw( 13 ) << s[ j ] << endl;\n} // end main\nArray Partial Initialization\nBe careful when partially initializing arrays (may return unexpected results)\nInitialize all elements to zero\nIf there are fewer values in the Initializer List then the remaining elements are initialized to zero\nIf there are no values in the Initializer List then all elements are initialized to zero\nFollowing statement declares array num with 5 elements, and initializes ALL elements to zero (0):\nint num[5] = {0};\nFollowing statement declares array n with 10 elements and initializes all elements to 0\nint n[10] = {};  //initialize all elements of array n to 0\nFollowing statement declares array num with 5 elements,\nand initializes num[0] to 8, num[1] to 5, num[2] to 12, all others to 0\nint num[5] = {8, 5, 12};\nFollowing statement declares array num with 3 elements,\nand initializes num[0] to 5, num[1] to 6, and num[2] to 3\nint num[] = {5, 6, 3};\nFollowing statement declares array num with 100 elements,\nand initializes num[0] to 4, num[1] to 7, all others to 0\nint num[100]= {4, 7};\nArray Processing Restrictions\nC++ does not allow aggregate operations on arrays (e.g., assignment, reading and printing contents of array--must be done element-wise)\nAggregate operation: any operation that manipulates entire collection (e.g., array) as single unit\n\n  int myArray[5] = {2, 4, 6, 8, 10};\n  int yourArray[5];\n\n  yourArray = myArray; //illegal assignment \nMust perform member-wise copy:\n\n  int myArray[5] = {2, 4, 6, 8, 10};\n  int yourArray[5];\n\n  //legal, member-wise copy\n  for (int i=0; i < 5; i++)\n    yourArray[i] = myArray[i];\nSame with IO: must perform member-wise instructions:\n\n  int myArray[5];\n\n  cout << myArray; //illegal\n  cin >> myArray; //illegal\n\n  //legal, member-wise input\n  for (int i=0; i < 5; i++)\n    cin >> myArray[i];\n\n  //legal, member-wise output\n  for (int i=0; i < 5; i++)\n    cout << myArray[i];\nArrays as Parameters\nArrays passed by reference only\nAmpersand (&) not used when declaring array as formal parameter--still passed by reference\nCan omit array size during declaration as formal parameter--ignored by compiler when specified\nBase address of array passed to formal parameter\nArray name is address of the first element\nGood programming practice: using reserved word const in declaration of array as formal parameter\nprevents function from altering actual parameter\n\n//Function to print array:\n//array and number of elements passed to parameters\n//listSize specifies number of elements to be printed\nvoid printArray(const int list[], int listSize)\n{\nint counter;\n\nfor (counter = 0; counter < listSize; counter++)\n  cout << list[counter] << \" \";\n}\nIn function call statement, when passing array as actual parameter, only use array name--NO brackets ([]):\n\n//Call to function printArray(), list is one-dimensional array\n//arraySize is scalar variable of type integer\nprintArray(list,arraySize);\nArray's Base Address:\nBase address: memory location of first array element\nExample: if num is one-dimensional array,\nbase address of num is address (memory location) of num[0]\nWhen passing arrays as parameters, base address of array passed to formal parameter\nFunctions cannot return value of type array\n\n___________________________________________________________________________________________________________________________________________________________________________\nIntro to Vectors\nC++ Standard Template Library class template vector\nCapabilities that are not provided for C style pointer-based arrays\nMore robust type of array\nCan be defined to store any data type using following format\n  vector< type > name( size );\nVectors use template notation (not covered yet)\nMore powerful, less error prone alternative to arrays\nAccess to member functions\nSee Fig 7.25\n\n______________________________________________________________________________________________________________________________________________________________________\nArrays vs. Vectors\nProblems with Arrays vs. Vectors (and other containers: list, map, etc.):\n\nAn array is a homogeneous data structure (elements have same data type) that stores a sequence of consecutively numbered objects--allocated in contiguous memory. Each object of the array can be accessed by using its number (i.e., index). When you declare an array, you set its size. (It's possible to create \"dynamic\" arrays, but still array sizes, once set, cannot be altered). The array cannot hold any more elements than its initial size. For example:\n\nint myArray[] = new int[5];\nThis snippet of code will create an array (on the \"heap\" or \"free store\" memory, using the new keyword) holding up to five integers. If more elements are desired (say, a 6th or 7th integer), a larger array will need to be declared, and all of the elements from the old array copied into the new one--and adding the 6th or 7th integer to the new array.\n\nFor these and other reasons, arrays can be difficult to use reliably...\n\nWhat's wrong with arrays?\nUnknown size: arrays don't know their own size\nFixed size: can't modify once set\nLack of subscript (range) checking: can go out-of-bounds, (cause for buffer overflow)\nArray name converts to a pointer to its first element (potentially causing problems--any of the above)\nVector benefits:\neasier to write\neasier to read\nless error prone\nin many applications, just as fast, also...\ninherent support to: add new elements beyond current size, resize, sort, search, erase elements, etc.\n  void f(int a[], int s)\n  {\n      // do something with a; the size of a is s\n      for (int i = 0; i < s; ++i) a[i] = i;\n  }\n\n  int arr1[20];\n  int arr2[10];\n\n  void g()\n  {\n      f(arr1,20);\n      f(arr2,20);\n  }\nThe second call will write all over memory that doesn't belong to arr2. Generally, a programmer will get the size right, but it's extra work, and, sometimes, every so often someone makes the mistake. A simpler and cleaner version using the standard library vector:\n  void f(vector& v)\n  {\n\t// do something with v\n\tfor (int i = 0; i < v.size(); ++i) v[i] = i;\n  }\n\n  vector v1(20);\n  vector v2(10);\n\n  void g()\n  {\n\tf(v1);\n\tf(v2);\n  }\nSince an array doesn't know its size, there can be no array assignment:\n  void f(int a[], int b[], int size)\n  {\n\ta = b;\t// not array assignment\n\tmemcpy(a,b,size);\t// a = b\n\t// ...\n  }\nAgain, vector:\n  void g(vector& a, vector& b, int size)\n  {\n\ta = b;\t\n\t// ...\n  }\nAnother advantage of vector here is that memcpy() is not going to do the right thing for elements with copy constructors, such as strings.\n  void f(string a[], string b[], int size)\n  {\n\ta = b;\t// not array assignment\n\tmemcpy(a,b,size);\t// disaster\n\t// ...\n  }\nUsing vector...\n  void g(vector& a, vector& b, int size)\n  {\n\ta = b;\t\n\t// ...\n  }\nAn array is of a fixed size determined at compile time (unless placed on the \"free store\" or \"heap\" and accessed through pointers):\n  const int S = 10;\n\n  void f(int s)\n  {\n\tint a1[s];\t// error\n\tint a2[S];\t// ok\n\n\t// to extend a2, must change to an array\n\t// allocated on free store using malloc() and use realloc() (C-style)\n\t// ...or, use new and delete (C++-style)\n  }\nIn contrast using vectors:\n  const int S = 10;\n\n  void g(int s)\n  {\n\tvector v1(s);\t// ok\n\tvector v2(S);\t// ok\n\tv2.resize(v2.size() * 2);\n\t// ...\n  }\n\n______________________________________________________________________________________________________________________________________________________________________________________________\nBenefits of Arrays over Vectors:\nNotational support for initialization or arrays (not with vectors)\nchar myChar[] = \"Test\"; //array of 4 characters\nA vector is a container class while an array is an allocated memory\nCan directly access element of array from memory, in vector or other container classes, must use specific functions.\nConsider the following snippet of code...\nstatic const char* suits[4] = { \"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\" };\nWill this list change during the program life-cycle? No. Will members need to be manipulated, searched, or various other operations performed? No. We just need a reference list. Do we need a vector? No.\n\nMuch of the time, just need to allocate space for storage. That is, hold some data somewhere. The art of programming is choosing the right tool for the job.\n");
              setContent("                                    9. Data Types, Arrays and Strings\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j31ActionPerformed

    private void j32ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j32ActionPerformed
        jTextPane1.setText("What is a Pointer?\n\nThe basic definition of a pointer is a variable that stores an address. Pointers are used to store the adresses of other variables. Normally a variable contains a specific value. A pointer on the other hand contains the memory address of a variable which, in turn, contains a specific value.\n\nPrinciple of Least Privilege - code should be granted only the amount of privilege and access needed to accomplish its task, but no more.\n\nA variable name directly references a value\nA pointer indirectly references a value\nReferencing a value through a pointer is referred to as indirection\nDeclaring Pointers:\nPointer declarations use the * operator described further below.\n  typeName* variableName;\nWe can declare multiple variables of the same type on one line, but for a pointer you must include the * operator for each.\n  int x, y, z;       //declaration of three variables of type int\n  int* p, q, r;      //appears to declare three pointers to ints, but actually creates one pointer and two ints.\n  int * p, * q, * r; //correct way to declare three pointers to ints on one line \nThe following is read from right to left as, countPtr is a pointer to int\n  int count;        //declaration of variable count\n  int* countPtr;    //declaration of pointer countPtr\nThe notation can be confusing because of the placement of *. The following three declarations are identical. They all declare countPtr as a pointer to an int.\n  int* countPtr;\n  int *countPtr;\n  int * countPtr;\nPointer Operators:\naddress operator &\nUnary operator\nObtains the memory address of its operand\nBelow, &y means \"address of y\"\n  int y = 5;  // declare variable y\n  int* yPtr;  // declare pointer variable yPtr\n\n  yPtr = &y;  // assign address of y to yPtr\nNote: Not the same as & in a reference variable declaration which is always preceded by a data-type name.\nWhen declaring a reference, the & is part of the type.\n  int& count;\nindirection or dereferencing operator *\nReturns an alias for the object to which its pointer operand points\nIn the declaration statement, the type appears before the *\n  std::cout << *yPtr << endl;  // prints the value of y\n\n  just as,\n\n  std::cout << y << endl;      // prints the vlaue of y \nAfter the declaration statement, the * is dereferencing the pointer to obtain the value\nYou can return the actual data item or value by dereferencing the pointer\n  cout << \"The data value is \" << *yPtr;  // prints the value\nRepeating the code snippet from above, for simplicity suppose the address stored is 1234 (also see Fig 8.4 in text)\n  int y = 5;  // declare variable y\n  int* yPtr;  // declare pointer variable yPtr\n\n  yPtr = &y;  // assign address of y to yPtr\n\n  cout << \"The pointer is: \" << yPtr;     // prints the pointer\n  cout << \"The data value is \" << *yPtr;  // prints the value\n\n  // Output\n  // The pointer is: 1234  // actual output depends on address\n  // The value is: 5\nCan also be used on the left side of an assignment statement. The following assigns 9 to y:\n  *yPtr = 9;\nInitializing Pointers:\nPointers should be initialized to 0, NULL or an address when declared or in an assignment\nNULL Pointer\n  int* yPtr;\n  yPtr = 0;\n  --OR--\n  int* yPtr = 0;\n0 is the only integer literal that can be assigned to a pointer\nA pointer with the value 0 or NULL points to nothing, i.e. null pointer\nInitializing a pointer to NULL is equivalent to initializing it to 0\nIn C++, 0 is used by convention\nTypically a placeholder to initialize pointers until their actual values are known\nInitializing pointers prevents accessing unknown or unitialized areas of memory\nIf a pointer's value is unknown, it will likely be random memory garbage and unsafe to dereference.\nDon't try to dereference a null pointer - results in a segmentation fault\nIf you always set pointers to null or another valid target, you can test prior to dereferencing as in,\n  if (yPtr != 0)      // safe to dereference\n    cout << *yPtr;\nMay be assigned to a pointer of the same type\n  int * xPtr, * yPtr;  // two pointers to int\n  xPtr = yPtr;         // both point to the same location\nInitialize with an address\n  int y = 5;  // declare variable y\n  int* yPtr;  // declare pointer variable yPtr\n\n  yPtr = &y;  // assign address of y to yPtr\nSample Executable\n// Fig. 8.4: fig08_04.cpp\n// Pointer operators & and *.\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n   int a; // a is an integer\n   int *aPtr; // aPtr is an int * which is a pointer to an integer\n\n   a = 7; // assigned 7 to a\n   aPtr = &a; // assign the address of a to aPtr\n\n   cout << \"The address of a is \" << &a\n      << \"\\nThe value of aPtr is \" << aPtr;\n   cout << \"\\n\\nThe value of a is \" << a\n      << \"\\nThe value of *aPtr is \" << *aPtr;\n   cout << \"\\n\\nShowing that * and & are inverses of \"\n      << \"each other.\\n&*aPtr = \" << &*aPtr\n      << \"\\n*&aPtr = \" << *&aPtr << endl;\n} // end main\nPass-by-Reference with Pointers:\nPrinciple of Least Privilege\nUse pointers and the dereference operator * to pass-by-reference\nWhen calling a function with an argument that should be modified, pass the address\nThe name of an array is the address of the first element of that array\nDirect access to value - modifies value directly\nA function receiving an address as an argument must define a pointer to receive the address. (see the function header below)\n// Fig. 8.7: fig08_07.cpp\n// Pass-by-reference with a pointer argument used to cube a \n// variable's value\n#include <iostream>\nusing namespace std;\n\nvoid cubeByReference( int * ); // prototype\n\nint main()\n{\n   int number = 5;\n\n   cout << \"The original value of number is \" << number;\n\n   cubeByReference( &number ); // pass number address to cubeByReference\n\n   cout << \"\\nThe new value of number is \" << number << endl;\n} // end main\n\n// calculate cube of *nPtr; modifies variable number in main\nvoid cubeByReference( int *nPtr )\n{\n   *nPtr = *nPtr * *nPtr * *nPtr; // cube *nPtr\n} // end function cubeByReference\nCompare to the follwing example using pass-by-value\n// Fig. 8.6: fig08_06.cpp\n// Pass-by-value used to cube a variable\n#include <iostream>\nusing namespace std;\n\nint cubeByValue( int ); // prototype\n\nint main()\n{\n   int number = 5;\n\n   cout << \"The original value of number is \" << number;\n\n   number = cubeByValue( number ); // pass number by value to cubeByValue\n   cout << \"\\nThe new value of number is \" << number << endl;\n} // end main\n\n// calculate and return cube of integer argument\nint cubeByValue( int n )\n{\n   return n * n * n; // cube local variable n and return result\n} // end function cubeByValue\nconstness of Pointers:\nPrinciple of Least Privilege\nThe use of const enables you to inform the compiler that the value of a particular variable should NOT be modified\nFour ways to pass a pointer to a function:\nNonconstant Pointer to Nonconstant Data\nHighest access granted\nData can be modified through the dereferenced pointer\nPointer can be modified to point to other data\nRead from right to left as \"countPtr is a pointer to an integer\"\n  int* countPtr;\nNonconstant Pointer to Constant Data\nPointer can be modified to point to other data\nThe data to which it points can NOT be modified\nUseful when passing an array to a function that will access all elements of the array but shouldn't modify the data\nRead from right to left as \"countPtr is a pointer to a constant integer\"\n  const int* countPtr;\nConstant Pointer to Nonconstant Data\nPointer always points to the same memory location\nData can be modified\nPointer can NOT be modified to point to other data\nSince the pointer is const it must be initialized when declared\nAn example is array name which is a constant pointer to the beginning of the array\nRead from right to left as \"countPtr is a constant pointer to a nonconstant integer\"\n  int* const countPtr = &x;  //const pointer must be initialized when declared\nConstant Pointer to Constant Data\nMinimum access granted\nPointer always points to the same memory location\nData can NOT be modified\nPointer can NOT be modified to point to other data\nSince the pointer is const it must be initialized when declared\nRead from right to left as \"countPtr is a constant pointer to a constant integer\"\n  const int* const countPtr = &x;  //const pointer must be initialized when declared\nPointer Arithmetic\nCertain arithmetic operations may be performed on pointers\nPointer arithmetic is only meaningful when performed on pointers that point to an array\nArithmetic Operations\nIncremented (++) or Decremented (--)\nInteger may be added to (+ or +=) or subtracted from (- or -=)\nOne pointer may be subtracted from another of the same type resulting in the distance between the two in bytes\nOperations are not literal but instead add or subtract the number of units\nsizeof Operator\ndetermines the size of any data type, variable or constant in bytes during program compilation\nFig 8.15\n");
         setContent("                                    10. Pointers\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j32ActionPerformed

    private void GetStarted3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GetStarted3ActionPerformed
         jTextPane1.setText("C is a general-purpose, high-level language that was originally developed by Dennis M. Ritchie to develop the UNIX operating system at Bell Labs. C was originally first implemented on the DEC PDP-11 computer in 1972.\n\nIn 1978, Brian Kernighan and Dennis Ritchie produced the first publicly available description of C, now known as the K&R standard.\n\nThe UNIX operating system, the C compiler, and essentially all UNIX application programs have been written in C. C has now become a widely used professional language for various reasons \n\nEasy to learn\nStructured language\nIt produces efficient programs\nIt can handle low-level activities\nIt can be compiled on a variety of computer platforms\nFacts about C\nC was invented to write an operating system called UNIX.\n\nC is a successor of B language which was introduced around the early 1970s.\n\nThe language was formalized in 1988 by the American National Standard Institute (ANSI).\n\nThe UNIX OS was totally written in C.\n\nToday C is the most widely used and popular System Programming Language.\n\nMost of the state-of-the-art software have been implemented using C.\n\nToday's most popular Linux OS and RDBMS MySQL have been written in C.\n\nWhy use C?\nC was initially used for system development work, particularly the programs that make-up the operating system. C was adopted as a system development language because it produces code that runs nearly as fast as the code written in assembly language. Some examples of the use of C might be \n\nOperating Systems\nLanguage Compilers\nAssemblers\nText Editors\nPrint Spoolers\nNetwork Drivers\nModern Programs\nDatabases\nLanguage Interpreters\nUtilities\nC Programs\nA C program can vary from 3 lines to millions of lines and it should be written into one or more text files with extension \".c\"; for example, hello.c. You can use \"vi\", \"vim\" or any other text editor to write your C program into a file.\n\nThis tutorial assumes that you know how to edit a text file and how to write source code inside a program file.");
         setContent("                                    1. Overview\n\n");
             jTabbedPane1.setSelectedIndex(2);        // TODO add your handling code here:
    }//GEN-LAST:event_GetStarted3ActionPerformed

    private void j34ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j34ActionPerformed
        jTextPane1.setText("C is a general-purpose, high-level language that was originally developed by Dennis M. Ritchie to develop the UNIX operating system at Bell Labs. C was originally first implemented on the DEC PDP-11 computer in 1972.\n\nIn 1978, Brian Kernighan and Dennis Ritchie produced the first publicly available description of C, now known as the K&R standard.\n\nThe UNIX operating system, the C compiler, and essentially all UNIX application programs have been written in C. C has now become a widely used professional language for various reasons \n\nEasy to learn\nStructured language\nIt produces efficient programs\nIt can handle low-level activities\nIt can be compiled on a variety of computer platforms\nFacts about C\nC was invented to write an operating system called UNIX.\n\nC is a successor of B language which was introduced around the early 1970s.\n\nThe language was formalized in 1988 by the American National Standard Institute (ANSI).\n\nThe UNIX OS was totally written in C.\n\nToday C is the most widely used and popular System Programming Language.\n\nMost of the state-of-the-art software have been implemented using C.\n\nToday's most popular Linux OS and RDBMS MySQL have been written in C.\n\nWhy use C?\nC was initially used for system development work, particularly the programs that make-up the operating system. C was adopted as a system development language because it produces code that runs nearly as fast as the code written in assembly language. Some examples of the use of C might be \n\nOperating Systems\nLanguage Compilers\nAssemblers\nText Editors\nPrint Spoolers\nNetwork Drivers\nModern Programs\nDatabases\nLanguage Interpreters\nUtilities\nC Programs\nA C program can vary from 3 lines to millions of lines and it should be written into one or more text files with extension \".c\"; for example, hello.c. You can use \"vi\", \"vim\" or any other text editor to write your C program into a file.\n\nThis tutorial assumes that you know how to edit a text file and how to write source code inside a program file.");
         setContent("                                    1. Overview\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j34ActionPerformed

    private void j35ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j35ActionPerformed
        jTextPane1.setText("Program to Display \"Hello, World!\"\n\n________________________________________________________________\n#include <stdio.h>\nint main()\n{\n   // printf() displays the string inside quotation\n   printf(\"Hello, World!\");\n   return 0;\n}\n____________________________________________________________________\n\nOutput :-\n\nHello, World!");
         setContent("                                    2. Hello World Programme\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j35ActionPerformed

    private void j36ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j36ActionPerformed
        jTextPane1.setText("Data Types in C\nA data type specifies the type of data that a variable can store such as integer, floating, character, etc.\n\nC Data Types\nThere are the following data types in C language.\n\nTypes\t                    Data Types\nBasic Data Type\tint, char, float, double\nDerived Data Type\tarray, pointer, structure, union\nEnumeration Data Type\tenum\nVoid Data Type\tvoid\n\n\n \nBasic Data Types\nThe basic data types are integer-based and floating-point based. C language supports both signed and unsigned literals.\n\nThe memory size of the basic data types may change according to 32 or 64-bit operating system.\n\nLet's see the basic data types. Its size is given according to 32-bit architecture.\n___________________________________________________________________________________\nData Types\t                 Memory Size  \t   Range\n___________________________________________________________________________________\nchar\t                    1 byte\t128 to 127\nsigned char\t                     1 byte\t128 to 127\nunsigned char\t1 byte\t0 to 255\nshort\t                     2 byte\t32,768 to 32,767\nsigned short\t                     2 byte\t32,768 to 32,767\nunsigned short\t2 byte\t0 to 65,535\nint\t                     2 byte\t32,768 to 32,767\nsigned int\t                     2 byte\t32,768 to 32,767\nunsigned int\t                     2 byte\t0 to 65,535\nshort int\t                     2 byte\t32,768 to 32,767\nsigned short int\t2 byte\t32,768 to 32,767\nunsigned short int\t2 byte\t0 to 65,535\nlong int\t                     4 byte\t-2,147,483,648 to 2,147,483,647\nsigned long int\t4 byte\t-2,147,483,648 to 2,147,483,647\nunsigned long int\t4 byte\t0 to 4,294,967,295\nfloat\t                      4 byte\t\ndouble\t                      8 byte\t\nlong double\t                      10 byte");
        setContent("                                    3. Data Types\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j36ActionPerformed

    private void j37ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j37ActionPerformed
        jTextPane1.setText("C Programming Operators\nIn this tutorial, you will learn about different operators in C programming with the help of examples.\n\n\nAn operator is a symbol that operates on a value or a variable. For example: + is an operator to perform addition.\n\nC has a wide range of operators to perform various operations.\n\nC Arithmetic Operators\nAn arithmetic operator performs mathematical operations such as addition, subtraction, multiplication, division etc on numerical values (constants and variables).\n\nOperator\tMeaning of Operator\n+\taddition or unary plus\n-\tsubtraction or unary minus\n*\tmultiplication\n/\tdivision\n%\tremainder after division (modulo division)\nExample 1: Arithmetic Operators\n// Working of arithmetic operators\n#include <stdio.h>\nint main()\n{\n    int a = 9,b = 4, c;\n    \n    c = a+b;\n    printf(\"a+b = %d \\n\",c);\n    c = a-b;\n    printf(\"a-b = %d \\n\",c);\n    c = a*b;\n    printf(\"a*b = %d \\n\",c);\n    c = a/b;\n    printf(\"a/b = %d \\n\",c);\n    c = a%b;\n    printf(\"Remainder when a divided by b = %d \\n\",c);\n    \n    return 0;\n}\n\nOutput\n\na+b = 13\na-b = 5\na*b = 36\na/b = 2\nRemainder when a divided by b=1\nThe operators +, - and * computes addition, subtraction, and multiplication respectively as you might have expected.\n\nIn normal calculation, 9/4 = 2.25. However, the output is 2 in the program.\n\nIt is because both the variables a and b are integers. Hence, the output is also an integer. The compiler neglects the term after the decimal point and shows answer 2 instead of 2.25.\n\nThe modulo operator % computes the remainder. When a=9 is divided by b=4, the remainder is 1. The % operator can only be used with integers.\n\nSuppose a = 5.0, b = 2.0, c = 5 and d = 2. Then in C programming,\n\n// Either one of the operands is a floating-point number\na/b = 2.5  \na/d = 2.5  \nc/b = 2.5  \n\n// Both operands are integers\nc/d = 2\nC Increment and Decrement Operators\nC programming has two operators increment ++ and decrement -- to change the value of an operand (constant or variable) by 1.\n\nIncrement ++ increases the value by 1 whereas decrement -- decreases the value by 1. These two operators are unary operators, meaning they only operate on a single operand.\n\nExample 2: Increment and Decrement Operators\n// Working of increment and decrement operators\n#include <stdio.h>\nint main()\n{\n    int a = 10, b = 100;\n    float c = 10.5, d = 100.5;\n\n    printf(\"++a = %d \\n\", ++a);\n    printf(\"--b = %d \\n\", --b);\n    printf(\"++c = %f \\n\", ++c);\n    printf(\"--d = %f \\n\", --d);\n\n    return 0;\n}\nOutput\n\n++a = 11\n--b = 99\n++c = 11.500000\n--d = 99.500000\nHere, the operators ++ and -- are used as prefixes. These two operators can also be used as postfixes like a++ and a--. Visit this page to learn more about how increment and decrement operators work when used as postfix.\n\nC Assignment Operators\nAn assignment operator is used for assigning a value to a variable. The most common assignment operator is =\n\nOperator\tExample\tSame as\n=\ta = b\ta = b\n+=\ta += b\ta = a+b\n-=\ta -= b\ta = a-b\n*=\ta *= b\ta = a*b\n/=\ta /= b\ta = a/b\n%=\ta %= b\ta = a%b\nExample 3: Assignment Operators\n// Working of assignment operators\n#include <stdio.h>\nint main()\n{\n    int a = 5, c;\n\n    c = a;      // c is 5\n    printf(\"c = %d\\n\", c);\n    c += a;     // c is 10 \n    printf(\"c = %d\\n\", c);\n    c -= a;     // c is 5\n    printf(\"c = %d\\n\", c);\n    c *= a;     // c is 25\n    printf(\"c = %d\\n\", c);\n    c /= a;     // c is 5\n    printf(\"c = %d\\n\", c);\n    c %= a;     // c = 0\n    printf(\"c = %d\\n\", c);\n\n    return 0;\n}\nOutput\n\nc = 5 \nc = 10 \nc = 5 \nc = 25 \nc = 5 \nc = 0\nC Relational Operators\nA relational operator checks the relationship between two operands. If the relation is true, it returns 1; if the relation is false, it returns value 0.\n\nRelational operators are used in decision making and loops.\n\nOperator\tMeaning of Operator\tExample\n==\tEqual to\t5 == 3 is evaluated to 0\n>\tGreater than\t5 > 3 is evaluated to 1\n<\tLess than\t5 < 3 is evaluated to 0\n!=\tNot equal to\t5 != 3 is evaluated to 1\n>=\tGreater than or equal to\t5 >= 3 is evaluated to 1\n<=\tLess than or equal to\t5 <= 3 is evaluated to 0\nExample 4: Relational Operators\n// Working of relational operators\n#include <stdio.h>\nint main()\n{\n    int a = 5, b = 5, c = 10;\n\n    printf(\"%d == %d is %d \\n\", a, b, a == b);\n    printf(\"%d == %d is %d \\n\", a, c, a == c);\n    printf(\"%d > %d is %d \\n\", a, b, a > b);\n    printf(\"%d > %d is %d \\n\", a, c, a > c);\n    printf(\"%d < %d is %d \\n\", a, b, a < b);\n    printf(\"%d < %d is %d \\n\", a, c, a < c);\n    printf(\"%d != %d is %d \\n\", a, b, a != b);\n    printf(\"%d != %d is %d \\n\", a, c, a != c);\n    printf(\"%d >= %d is %d \\n\", a, b, a >= b);\n    printf(\"%d >= %d is %d \\n\", a, c, a >= c);\n    printf(\"%d <= %d is %d \\n\", a, b, a <= b);\n    printf(\"%d <= %d is %d \\n\", a, c, a <= c);\n\n    return 0;\n}\nOutput\n\n5 == 5 is 1\n5 == 10 is 0\n5 > 5 is 0\n5 > 10 is 0\n5 < 5 is 0\n5 < 10 is 1\n5 != 5 is 0\n5 != 10 is 1\n5 >= 5 is 1\n5 >= 10 is 0\n5 <= 5 is 1\n5 <= 10 is 1 \nC Logical Operators\nAn expression containing logical operator returns either 0 or 1 depending upon whether expression results true or false. Logical operators are commonly used in decision making in C programming.\n\nOperator\tMeaning\tExample\n&&\tLogical AND. True only if all operands are true\tIf c = 5 and d = 2 then, expression ((c==5) && (d>5)) equals to 0.\n||\tLogical OR. True only if either one operand is true\tIf c = 5 and d = 2 then, expression ((c==5) || (d>5)) equals to 1.\n!\tLogical NOT. True only if the operand is 0\tIf c = 5 then, expression !(c==5) equals to 0.\nExample 5: Logical Operators\n// Working of logical operators\n\n#include <stdio.h>\nint main()\n{\n    int a = 5, b = 5, c = 10, result;\n\n    result = (a == b) && (c > b);\n    printf(\"(a == b) && (c > b) is %d \\n\", result);\n\n    result = (a == b) && (c < b);\n    printf(\"(a == b) && (c < b) is %d \\n\", result);\n\n    result = (a == b) || (c < b);\n    printf(\"(a == b) || (c < b) is %d \\n\", result);\n\n    result = (a != b) || (c < b);\n    printf(\"(a != b) || (c < b) is %d \\n\", result);\n\n    result = !(a != b);\n    printf(\"!(a != b) is %d \\n\", result);\n\n    result = !(a == b);\n    printf(\"!(a == b) is %d \\n\", result);\n\n    return 0;\n}\nOutput\n\n(a == b) && (c > b) is 1 \n(a == b) && (c < b) is 0 \n(a == b) || (c < b) is 1 \n(a != b) || (c < b) is 0 \n!(a != b) is 1 \n!(a == b) is 0 \nExplanation of logical operator program\n\n(a == b) && (c > 5) evaluates to 1 because both operands (a == b) and (c > b) is 1 (true).\n(a == b) && (c < b) evaluates to 0 because operand (c < b) is 0 (false).\n(a == b) || (c < b) evaluates to 1 because (a = b) is 1 (true).\n(a != b) || (c < b) evaluates to 0 because both operand (a != b) and (c < b) are 0 (false).\n!(a != b) evaluates to 1 because operand (a != b) is 0 (false). Hence, !(a != b) is 1 (true).\n!(a == b) evaluates to 0 because (a == b) is 1 (true). Hence, !(a == b) is 0 (false).\nC Bitwise Operators\nDuring computation, mathematical operations like: addition, subtraction, multiplication, division, etc are converted to bit-level which makes processing faster and saves power.\n\nBitwise operators are used in C programming to perform bit-level operations.\n\nOperators\tMeaning of operators\n&\tBitwise AND\n|\tBitwise OR\n^\tBitwise exclusive OR\n~\tBitwise complement\n<<\tShift left\n>>\tShift right\nVisit bitwise operator in C to learn more.\n\nOther Operators\nComma Operator\nComma operators are used to link related expressions together. For example:\n\nint a, c = 5, d;\nThe sizeof operator\nThe sizeof is a unary operator that returns the size of data (constants, variables, array, structure, etc).\n\nExample 6: sizeof Operator\n#include <stdio.h>\nint main()\n{\n    int a;\n    float b;\n    double c;\n    char d;\n    printf(\"Size of int=%lu bytes\\n\",sizeof(a));\n    printf(\"Size of float=%lu bytes\\n\",sizeof(b));\n    printf(\"Size of double=%lu bytes\\n\",sizeof(c));\n    printf(\"Size of char=%lu byte\\n\",sizeof(d));\n\n    return 0;\n}\nOutput\n\nSize of int = 4 bytes\nSize of float = 4 bytes\nSize of double = 8 bytes\nSize of char = 1 byte\n");
        setContent("                                    4. Operators\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j37ActionPerformed

    private void j38ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j38ActionPerformed
        jTextPane1.setText("C provides two sytles of flow control:\n\nBranching\n\nLooping\n\nBranching is deciding what actions to take and looping is deciding how many times to take a certain action.\n\nBranching:\nBranching is so called because the program chooses to follow one branch or another.\n\nif statement\nThis is the most simple form of the branching statements.\n\nIt takes an expression in parenthesis and an statement or block of statements. if the expression is true then the statement or block of statements gets executed otherwise these statements are skipped.\n\nNOTE: Expression will be assumed to be true if its evaulated values is non-zero.\n\nif statements take the following form:\n\nShow Example\n\nif (expression)\n  statement;\n\nor\n\nif (expression)\n  {\n    Block of statements;\n  }\n\nor\n\nif (expression)\n  {\n    Block of statements;\n  }\nelse\n  {\n    Block of statements;\n  }\n\nor\n\nif (expression)\n  {\n    Block of statements;\n  }\nelse if(expression)\n  {\n    Block of statements;\n  }\nelse\n  {\n    Block of statements;\n  }\n\n? : Operator\nThe ? : operator is just like an if ... else statement except that because it is an operator you can use it within expressions.\n\n? : is a ternary operator in that it takes three values, this is the only ternary operator C has.\n\n? : takes the following form:\n\nShow Example\n\nif condition is true ? then X return value : otherwise Y value;\nswitch statement:\nThe switch statement is much like a nested if .. else statement. Its mostly a matter of preference which you use, switch statement can be slightly more efficient and easier to read.\n\nShow Example\n\nswitch( expression )\n     {\n        case constant-expression1:\tstatements1;\n        [case constant-expression2:\tstatements2;]    \n        [case constant-expression3:\tstatements3;]\n        [default : statements4;]\n     }\nUsing break keyword:\nIf a condition is met in switch case then execution continues on into the next case clause also if it is not explicitly specified that the execution should exit the switch statement. This is achieved by using break keyword.\n\nTry out given example Show Example\n\nWhat is default condition:\nIf none of the listed conditions is met then default condition executed.\n\nTry out given example Show Example\n\nLooping\nLoops provide a way to repeat commands and control how many times they are repeated. C provides a number of looping way.\n\nwhile loop\nThe most basic loop in C is the while loop.A while statement is like a repeating if statement. Like an If statement, if the test condition is true: the statments get executed. The difference is that after the statements have been executed, the test condition is checked again. If it is still true the statements get executed again.This cycle repeats until the test condition evaluates to false.\n\nBasic syntax of while loop is as follows:\n\nShow Example\n\nwhile ( expression )\n{\n   Single statement \n   or\n   Block of statements;\n}\nfor loop\nfor loop is similar to while, it's just written differently. for statements are often used to proccess lists such a range of numbers:\n\nBasic syntax of for loop is as follows:\n\nShow Example\n\nfor( expression1; expression2; expression3)\n{\n   Single statement\n   or\n   Block of statements;\n}\n\nIn the above syntax:\n\nexpression1 - Initialisese variables.\nexpression2 - Condtional expression, as long as this condition is true, loop will keep executing.\nexpression3 - expression3 is the modifier which may be simple increment of a variable.\ndo...while loop\ndo ... while is just like a while loop except that the test condition is checked at the end of the loop rather than the start. This has the effect that the content of the loop are always executed at least once.\n\nBasic syntax of do...while loop is as follows:\n\nShow Example\n\ndo\n{\n   Single statement\n   or\n   Block of statements;\n}while(expression);\nbreak and continue statements\nC provides two commands to control how we loop:\n\nbreak -- exit form loop or switch.\ncontinue -- skip 1 iteration of loop.\nYou already have seen example of using break statement. Here is an example showing usage of continue statement.\n\n#include \n\nmain()\n{\n    int i;\n    int j = 10;\n\n    for( i = 0; i <= j; i ++ )\n    {\n       if( i == 5 )\n       {\n          continue;\n       }\n       printf(\"Hello %d\\n\", i );\n    }\n}\nThis will produce following output:\n\nHello 0\nHello 1\nHello 2\nHello 3\nHello 4\nHello 6\nHello 7\nHello 8\nHello 9\nHello 10");
        setContent("                                    5. Statements and Flow Control\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j38ActionPerformed

    private void j39ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j39ActionPerformed
        jTextPane1.setText("Procedure Oriented Programming (POP):\nProcedure Oriented Programming consists of a set of instructions to be followed and divide these instructions into smaller parts known as functions in order for the computer to perform. C, VB, FORTRAN, Pascal are a few examples of POP.\n\nFeatures of POP :\nMainly focused on writing the algorithms.\nThe most function uses Global data for sharing which are accessed freely from function to function in the system.\nPOP follows the top-down approach in program design.\nIt does not have data hiding options.\nFunctions transform data from one form to another.\nData can be moved openly from one function to another around the system.\nSub-division of the large program into smaller programs called functions.\nOverloading process is not applicable in POP.\nProcedure Oriented Programming Features in C:\nC language uses the set of instruction to inform/guide computer what to do step by step.\nIts depend on the procedures, more specifically routines or subroutines.\nAs it follows the procedures, hence it adopts the top-down approach.\nApart from other languages like C++, C language are very much focused on the procedure that relates to the data.\nC language is much focused on the data hence on functions.\nIt is also well known as the structured programming language.");
         setContent("                                    6. Procedure Oriented Programming\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j39ActionPerformed

    private void j40ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j40ActionPerformed
        jTextPane1.setText("Example\n#\nBy default structures are padded in C. If you want to avoid this behaviour, you have to explicitly request it. Under GCC it's __attribute__((__packed__)). Consider this example on a 64-bit machine:\n\nstruct foo {\n    char *p;  /* 8 bytes */\n    char c;   /* 1 byte  */\n    long x;   /* 8 bytes */\n};\nThe structure will be automatically padded to have8-byte alignment and will look like this:\n\nstruct foo {\n    char *p;     /* 8 bytes */\n    char c;      /* 1 byte  */\n\n    char pad[7]; /* 7 bytes added by compiler */\n\n    long x;      /* 8 bytes */\n};\nSo sizeof(struct foo) will give us 24 instead of 17. This happened because of a 64 bit compiler read/write from/to Memory in 8 bytes of word in each step and obvious when try to write char c; a one byte in memory a complete 8 bytes (i.e. word) fetched and consumes only first byte of it and its seven successive of bytes remains empty and not accessible for any read and write operation for structure padding.\n\nStructure packing\n#\nBut if you add the attribute packed, the compiler will not add padding:\n\nstruct __attribute__((__packed__)) foo {\n    char *p;  /* 8 bytes */\n    char c;   /* 1 byte  */\n    long x;   /* 8 bytes */\n};\nNow sizeof(struct foo) will return 17.\n\nGenerally packed structures are used:\n\nTo save space.\nTo format a data structure to transmit over network without depending on each architecture alignment of each node of the network.\nIt must be taken in consideration that some processors such as the ARM Cortex-M0 do not allow unaligned memory access; in such cases, structure packing can lead to undefined behaviour and can crash the CPU.");
         setContent("                                    7. Packaging\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j40ActionPerformed

    private void j41ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j41ActionPerformed
        jTextPane1.setText("The C  is not a part of the compiler, but is a separate step in the compilation process. In simple terms, a C Preprocessor is just a text substitution tool and it instructs the compiler to do required pre-processing before the actual compilation. We'll refer to the C Preprocessor as CPP.\n\nAll preprocessor commands begin with a hash symbol (#). It must be the first nonblank character, and for readability, a preprocessor directive should begin in the first column. The following section lists down all the important preprocessor directives \n\nSr.No.\tDirective & Description\n1\t\n#define\n\nSubstitutes a preprocessor macro.\n\n2\t\n#include\n\nInserts a particular header from another file.\n\n3\t\n#undef\n\nUndefines a preprocessor macro.\n\n4\t\n#ifdef\n\nReturns true if this macro is defined.\n\n5\t\n#ifndef\n\nReturns true if this macro is not defined.\n\n6\t\n#if\n\nTests if a compile time condition is true.\n\n7\t\n#else\n\nThe alternative for #if.\n\n8\t\n#elif\n\n#else and #if in one statement.\n\n9\t\n#endif\n\nEnds preprocessor conditional.\n\n10\t\n#error\n\nPrints error message on stderr.\n\n11\t\n#pragma\n\nIssues special commands to the compiler, using a standardized method.\n\nPreprocessors Examples\nAnalyze the following examples to understand various directives.\n\n#define MAX_ARRAY_LENGTH 20\nThis directive tells the CPP to replace instances of MAX_ARRAY_LENGTH with 20. Use #define for constants to increase readability.\n\n#include <stdio.h>\n#include \"myheader.h\"\nThese directives tell the CPP to get stdio.h from System Libraries and add the text to the current source file. The next line tells CPP to get myheader.h from the local directory and add the content to the current source file.\n\n#undef  FILE_SIZE\n#define FILE_SIZE 42\nIt tells the CPP to undefine existing FILE_SIZE and define it as 42.\n\n#ifndef MESSAGE\n   #define MESSAGE \"You wish!\"\n#endif\nIt tells the CPP to define MESSAGE only if MESSAGE isn't already defined.\n\n#ifdef DEBUG\n   /* Your debugging statements here */\n#endif\nIt tells the CPP to process the statements enclosed if DEBUG is defined. This is useful if you pass the -DDEBUG flag to the gcc compiler at the time of compilation. This will define DEBUG, so you can turn debugging on and off on the fly during compilation.\n\nPredefined Macros\nANSI C defines a number of macros. Although each one is available for use in programming, the predefined macros should not be directly modified.\n\nSr.No.\tMacro & Description\n1\t\n__DATE__\n\nThe current date as a character literal in \"MMM DD YYYY\" format.\n\n2\t\n__TIME__\n\nThe current time as a character literal in \"HH:MM:SS\" format.\n\n3\t\n__FILE__\n\nThis contains the current filename as a string literal.\n\n4\t\n__LINE__\n\nThis contains the current line number as a decimal constant.\n\n5\t\n__STDC__\n\nDefined as 1 when the compiler complies with the ANSI standard.\n\nLet's try the following example \n\nLive Demo\n#include <stdio.h>\n\nint main() {\n\n   printf(\"File :%s\\n\", __FILE__ );\n   printf(\"Date :%s\\n\", __DATE__ );\n   printf(\"Time :%s\\n\", __TIME__ );\n   printf(\"Line :%d\\n\", __LINE__ );\n   printf(\"ANSI :%d\\n\", __STDC__ );\n\n}\nWhen the above code in a file test.c is compiled and executed, it produces the following result \n\nFile :test.c\nDate :Jun 2 2012\nTime :03:36:24\nLine :8\nANSI :1\nPreprocessor Operators\nThe C preprocessor offers the following operators to help create macros \n\nThe Macro Continuation (\\) Operator\nA macro is normally confined to a single line. The macro continuation operator (\\) is used to continue a macro that is too long for a single line. For example \n\n#define  message_for(a, b)  \\\n   printf(#a \" and \" #b \": We love you!\\n\")\nThe Stringize (#) Operator\nThe stringize or number-sign operator ( '#' ), when used within a macro definition, converts a macro parameter into a string constant. This operator may be used only in a macro having a specified argument or parameter list. For example \n\nLive Demo\n#include <stdio.h>\n\n#define  message_for(a, b)  \\\n   printf(#a \" and \" #b \": We love you!\\n\")\n\nint main(void) {\n   message_for(Carole, Debra);\n   return 0;\n}\nWhen the above code is compiled and executed, it produces the following result \n\nCarole and Debra: We love you!\nThe Token Pasting (##) Operator\nThe token-pasting operator (##) within a macro definition combines two arguments. It permits two separate tokens in the macro definition to be joined into a single token. For example \n\nLive Demo\n#include <stdio.h>\n\n#define tokenpaster(n) printf (\"token\" #n \" = %d\", token##n)\n\nint main(void) {\n   int token34 = 40;\n   tokenpaster(34);\n   return 0;\n}\nWhen the above code is compiled and executed, it produces the following result \n\ntoken34 = 40\nIt happened so because this example results in the following actual output from the preprocessor \n\nprintf (\"token34 = %d\", token34);\nThis example shows the concatenation of token##n into token34 and here we have used both stringize and token-pasting.\n\nThe Defined() Operator\nThe preprocessor defined operator is used in constant expressions to determine if an identifier is defined using #define. If the specified identifier is defined, the value is true (non-zero). If the symbol is not defined, the value is false (zero). The defined operator is specified as follows \n\nLive Demo\n#include <stdio.h>\n\n#if !defined (MESSAGE)\n   #define MESSAGE \"You wish!\"\n#endif\n\nint main(void) {\n   printf(\"Here is the message: %s\\n\", MESSAGE);  \n   return 0;\n}\nWhen the above code is compiled and executed, it produces the following result \n\nHere is the message: You wish!\nParameterized Macros\nOne of the powerful functions of the CPP is the ability to simulate functions using parameterized macros. For example, we might have some code to square a number as follows \n\nint square(int x) {\n   return x * x;\n}\nWe can rewrite above the code using a macro as follows \n\n#define square(x) ((x) * (x))\nMacros with arguments must be defined using the #define directive before they can be used. The argument list is enclosed in parentheses and must immediately follow the macro name. Spaces are not allowed between the macro name and open parenthesis. For example \n\nLive Demo\n#include <stdio.h>\n\n#define MAX(x,y) ((x) > (y) ? (x) : (y))\n\nint main(void) {\n   printf(\"Max between 20 and 10 is %d\\n\", MAX(10, 20));  \n   return 0;\n}\nWhen the above code is compiled and executed, it produces the following result \n\nMax between 20 and 10 is 20");
        setContent("                                    8. Preprocessor\n\n");
             jTabbedPane1.setSelectedIndex(2); // TODO add your handling code here:
    }//GEN-LAST:event_j41ActionPerformed

    private void j42ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j42ActionPerformed
        jTextPane1.setText("Error Handling in C programs\n\nAlthough C does not provide direct support to error handling (or exception handling), there are ways through which error handling can be done in C. A programmer has to prevent errors at the first place and test return values from the functions.\nA lot of C function calls return a -1 or NULL in case of an error, so quick test on these return values are easily done with for instance an if statement. For example, In Socket Programming, the returned value of the functions like socket(), listen() etc. are checked to see if there is an error or not.\n\nExample: Error handling in Socket Programming\n\nif ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)\n{\n   perror(\"socket failed\");\n   exit(EXIT_FAILURE);\n}\nDifferent methods of Error handling in C\n\nGlobal Variable errno: When a function is called in C, a variable named as errno is automatically assigned a code (value) which can be used to identify the type of error that has been encountered. Its a global variable indicating the error occurred during any function call and defined in the header file errno.h.\nDifferent codes (values) for errno mean different types of errors. Below is a list of few different errno values and its corresponding meaning:\nerrno value       Error\n1             /* Operation not permitted */\n2             /* No such file or directory */\n3             /* No such process */\n4             /* Interrupted system call */\n5             /* I/O error */\n6             /* No such device or address */\n7             /* Argument list too long */\n8             /* Exec format error */\n9             /* Bad file number */\n10            /* No child processes */\n11            /* Try again */\n12            /* Out of memory */\n13            /* Permission denied */\n\n\n// C implementation to see how errno value is\n// set in the case of any error in C\n#include <stdio.h>\n#include <errno.h>\n  \nint main()\n{\n    // If a file is opened which does not exist,\n    // then it will be an error and corresponding\n    // errno value will be set\n    FILE * fp;\n  \n    // opening a file which does\n    // not exist.\n    fp = fopen(\"GeeksForGeeks.txt\", \"r\");\n  \n    printf(\" Value of errno: %d\\n \", errno);\n  \n    return 0;\n}\nOutput:\n\n\n\n\nValue of errno: 2\nNote: Here the errno is set to 2 which means  No such file or directory. On online IDE it may give errorno 13, which says permission denied.\n\nperror() and strerror(): The errno value got above indicate the types of error encountered.\nIf it is required to show the error description, then there are two functions that can be used to display a text message that is associated with errorno. The functions are:\nperror: It displays the string you pass to it, followed by a colon, a space, and then the textual representation of the current errno value.\nSyntax:\nvoid perror (const char *str)\nstr: is a string containing a custom message\nto be printed before the error message itself.\nstrerror(): returns a pointer to the textual representation of the current errno value.\nSyntax:\nchar *strerror (int errnum)\nerrnum: is the error number (errno).\n\n// C implementation to see how perror() and strerror()\n// functions are used to print the error messages.\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n  \nint main ()\n{\n    FILE *fp;\n  \n    // If a file is opened which does not exist,\n    // then it will be an error and corresponding\n    // errno value will be set\n    fp = fopen(\" GeeksForGeeks.txt \", \"r\");\n  \n    // opening a file which does\n    // not exist.\n    printf(\"Value of errno: %d\\n \", errno);\n    printf(\"The error message is : %s\\n\", \n                         strerror(errno));\n    perror(\"Message from perror\");\n  \n    return 0;\n}\nOutput:\nOn Personal desktop:\n\nValue of errno: 2\nThe error message is : No such file or directory\nMessage from perror: No such file or directory\nOn online IDE:\n\n Value of errno: 13\nThe error message is : Permission denied\nNote: The function perror() displays a string passed to it, followed by a colon and the textual message of the current errno value.\n\n");
        setContent("                                    9. Exception Handling\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j42ActionPerformed

    private void j43ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j43ActionPerformed
        jTextPane1.setText("C Input Output (I/O)\nIn this tutorial, you will learn to use scanf() function to take input from the user, and printf() function to display output to the user.\n\n\nC Output\nIn C programming, printf() is one of the main output function. The function sends formatted output to the screen. For example,\n\nExample 1: C Output\n#include <stdio.h>    \nint main()\n{ \n    // Displays the string inside quotations\n    printf(\"C Programming\");\n    return 0;\n}\nOutput\n\nC Programming\nHow does this program work?\n\nAll valid C programs must contain the main() function. The code execution begins from the start of the main() function.\nThe printf() is a library function to send formatted output to the screen. The function prints the string inside quotations.\nTo use printf() in our program, we need to include stdio.h header file using the #include <stdio.h> statement.\nThe return 0; statement inside the main() function is the \"Exit status\" of the program. It's optional.\nExample 2: Integer Output\n#include <stdio.h>\nint main()\n{\n    int testInteger = 5;\n    printf(\"Number = %d\", testInteger);\n    return 0;\n}\nOutput\n\nNumber = 5\nWe use %d format specifier to print int types. Here, the %d inside the quotations will be replaced by the value of testInteger.\n\nExample 3: float and double Output\n#include <stdio.h>\nint main()\n{\n    float number1 = 13.5;\n    double number2 = 12.4;\n\n    printf(\"number1 = %f\\n\", number1);\n    printf(\"number2 = %lf\", number2);\n    return 0;\n}\nOutput\n\nnumber1 = 13.500000\nnumber2 = 12.400000\nTo print float, we use %f format specifier. Similarly, we use %lf to print double values.\n\nExample 4: Print Characters\n#include <stdio.h>\nint main()\n{\n    char chr = 'a';    \n    printf(\"character = %c\", chr);  \n    return 0;\n} \nOutput\n\ncharacter = a\n\nTo print char, we use %c format specifier.\n\nC Input\nIn C programming, scanf() is one of the commonly used function to take input from the user. The scanf() function reads formatted input from the standard input such as keyboards.\n\nExample 5: Integer Input/Output\n#include <stdio.h>\nint main()\n{\n    int testInteger;\n    printf(\"Enter an integer: \");\n    scanf(\"%d\", &testInteger);  \n    printf(\"Number = %d\",testInteger);\n    return 0;\n}\nOutput\n\nEnter an integer: 4\nNumber = 4\nHere, we have used %d format specifier inside the scanf() function to take int input from the user. When the user enters an integer, it is stored in the testInteger variable.\n\nNotice, that we have used &testInteger inside scanf(). It is because &testInteger gets the address of testInteger, and the value entered by the user is stored in that address.\n\nExample 6: Float and Double Input/Output\n#include <stdio.h>\nint main()\n{\n    float num1;\n    double num2;\n\n    printf(\"Enter a number: \");\n    scanf(\"%f\", &num1);\n    printf(\"Enter another number: \");\n    scanf(\"%lf\", &num2);\n\n    printf(\"num1 = %f\\n\", num1);\n    printf(\"num2 = %lf\", num2);\n\n    return 0;\n}\nOutput\n\nEnter a number: 12.523\nEnter another number: 10.2\nnum1 = 12.523000\nnum2 = 10.200000\nWe use %f and %lf format specifier for float and double respectively.\n\nExample 7: C Character I/O\n#include <stdio.h>\nint main()\n{\n    char chr;\n    printf(\"Enter a character: \");\n    scanf(\"%c\",&chr);     \n    printf(\"You entered %c.\", chr);  \n    return 0;\n}   \nOutput\n\nEnter a character: g\nYou entered g\nWhen a character is entered by the user in the above program, the character itself is not stored. Instead, an integer value (ASCII value) is stored.\n\nAnd when we display that value using %c text format, the entered character is displayed. If we use %d to display the character, it's ASCII value is printed.\n\nExample 8: ASCII Value\n#include <stdio.h>\nint main()\n{\n    char chr;\n    printf(\"Enter a character: \");\n    scanf(\"%c\", &chr);     \n\n    // When %c is used, a character is displayed\n    printf(\"You entered %c.\\n\",chr);  \n\n    // When %d is used, ASCII value is displayed\n    printf(\"ASCII value is %d.\", chr);  \n    return 0;\n}\nOutput\n\nEnter a character: g\nYou entered g.\nASCII value is 103.\nI/O Multiple Values\nHere's how you can take multiple inputs from the user and display them.\n\n#include <stdio.h>\nint main()\n{\n    int a;\n    float b;\n\n    printf(\"Enter integer and then a float: \");\n  \n    // Taking multiple inputs\n    scanf(\"%d%f\", &a, &b);\n\n    printf(\"You entered %d and %f\", a, b);  \n    return 0;\n}\nOutput\n\nEnter integer and then a float: -3\n3.4\nYou entered -3 and 3.400000\nFormat Specifiers for I/O\nAs you can see from the above examples, we use\n\n%d for int\n%f for float\n%lf for double\n%c for char\nHere's a list of commonly used C data types and their format specifiers.\n\nData Type\t                   Format Specifier\nint\t                       %d\nchar\t                        %c\nfloat\t                        %f\ndouble\t                         %lf\nshort int\t                        %hd\nunsigned int\t                           %u\nlong int\t                           %li\nlong long int\t                            %lli\nunsigned long int\t      %lu\nunsigned long long int\t      %llu\nsigned char\t                            %c\nunsigned char\t       %c\nlong double\t                             %Lf\n");
         setContent("                                    10. Input Output\n\n");
             jTabbedPane1.setSelectedIndex(2);//// TODO add your handling code here:
    }//GEN-LAST:event_j43ActionPerformed

    private void j44ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_j44ActionPerformed
        jTextPane1.setText("Multithreading in C\nDifficulty Level : Medium\nLast Updated : 10 Oct, 2018\nWhat is a Thread?\nA thread is a single sequence stream within in a process. Because threads have some of the properties of processes, they are sometimes called lightweight processes.\n\nWhat are the differences between process and thread?\nThreads are not independent of one other like processes as a result threads shares with other threads their code section, data section and OS resources like open files and signals. But, like process, a thread has its own program counter (PC), a register set, and a stack space.\n\nWhy Multithreading?\nThreads are popular way to improve application through parallelism. For example, in a browser, multiple tabs can be different threads. MS word uses multiple threads, one thread to format the text, other thread to process inputs, etc.\nThreads operate faster than processes due to following reasons:\n1) Thread creation is much faster.\n2) Context switching between threads is much faster.\n3) Threads can be terminated easily\n4) Communication between threads is faster.\n\n\n\n\nSee http://www.personal.kent.edu/~rmuhamma/OpSystems/Myos/threads.htm for more details.\n\nCan we write multithreading programs in C?\nUnlike Java, multithreading is not supported by the language standard. POSIX Threads (or Pthreads) is a POSIX standard for threads. Implementation of pthread is available with gcc compiler.\n\nA simple C program to demonstrate use of pthread basic functions\nPlease note that the below program may compile only with C compilers with pthread library.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>  //Header file for sleep(). man 3 sleep for details.\n#include <pthread.h>\n  \n// A normal C function that is executed as a thread \n// when its name is specified in pthread_create()\nvoid *myThreadFun(void *vargp)\n{\n    sleep(1);\n    printf(\"Printing GeeksQuiz from Thread \\n\");\n    return NULL;\n}\n   \nint main()\n{\n    pthread_t thread_id;\n    printf(\"Before Thread\\n\");\n    pthread_create(&thread_id, NULL, myThreadFun, NULL);\n    pthread_join(thread_id, NULL);\n    printf(\"After Thread\\n\");\n    exit(0);\n}\nIn main() we declare a variable called thread_id, which is of type pthread_t, which is an integer used to identify the thread in the system. After declaring thread_id, we call pthread_create() function to create a thread.\npthread_create() takes 4 arguments.\nThe first argument is a pointer to thread_id which is set by this function.\nThe second argument specifies attributes. If the value is NULL, then default attributes shall be used.\nThe third argument is name of function to be executed for the thread to be created.\nThe fourth argument is used to pass arguments to the function, myThreadFun.\nThe pthread_join() function for threads is the equivalent of wait() for processes. A call to pthread_join blocks the calling thread until the thread with identifier equal to the first argument terminates.\n\nHow to compile above program?\nTo compile a multithreaded program using gcc, we need to link it with the pthreads library. Following is the command used to compile the program.\n\ngfg@ubuntu:~/$ gcc multithread.c -lpthread\ngfg@ubuntu:~/$ ./a.out\nBefore Thread\nPrinting GeeksQuiz from Thread \nAfter Thread\ngfg@ubuntu:~/$ \nA C program to show multiple threads with global and static variables\nAs mentioned above, all threads share data segment. Global and static variables are stored in data segment. Therefore, they are shared by all threads. The following example program demonstrates the same.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <pthread.h>\n  \n// Let us create a global variable to change it in threads\nint g = 0;\n  \n// The function to be executed by all threads\nvoid *myThreadFun(void *vargp)\n{\n    // Store the value argument passed to this thread\n    int *myid = (int *)vargp;\n  \n    // Let us create a static variable to observe its changes\n    static int s = 0;\n  \n    // Change static and global variables\n    ++s; ++g;\n  \n    // Print the argument, static and global variables\n    printf(\"Thread ID: %d, Static: %d, Global: %d\\n\", *myid, ++s, ++g);\n}\n  \nint main()\n{\n    int i;\n    pthread_t tid;\n  \n    // Let us create three threads\n    for (i = 0; i < 3; i++)\n        pthread_create(&tid, NULL, myThreadFun, (void *)&tid);\n  \n    pthread_exit(NULL);\n    return 0;\n}");
        setContent("                                    11. Threading\n\n");
             jTabbedPane1.setSelectedIndex(2);// TODO add your handling code here:
    }//GEN-LAST:event_j44ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
    	  ApplicationContext ac=new ClassPathXmlApplicationContext("Configuration.xml");
          Login f=ac.getBean("login",Login.class);
          this.setVisible(false);
          f.setVisible(true);
       
    }//GEN-LAST:event_jButton2ActionPerformed

    private void JavaMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_JavaMouseMoved
jTextArea2.setText("Java is top pick as one of the most popular\n programming languages, used for building\n server-side applications to video games\n and mobile app");

// TODO add your handling code here:
    }//GEN-LAST:event_JavaMouseMoved

    private void JavaMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_JavaMouseExited
    jTextArea2.setText("");    // TODO add your handling code here:
    }//GEN-LAST:event_JavaMouseExited

    private void PythonMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_PythonMouseMoved
    jTextArea3.setText("Python is one of the most beginner-friendly\n programming languages you will find.\n Its perfect for learning the fundamentals of\n programming if youre just starting out with coding.");
        // TODO add your handling code here:
    }//GEN-LAST:event_PythonMouseMoved

    private void PythonMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_PythonMouseExited
        jTextArea3.setText(""); // TODO add your handling code here:
    }//GEN-LAST:event_PythonMouseExited

    private void Cpp1MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_Cpp1MouseMoved
        jTextArea4.setText("C++ is based on C, the indisputable dinosaur of programming\nlanguages still in use.C++ a powerful, high-performance\nlanguage, but its rather lower-level. Low-level programming\nlanguages use a lower degree of abstraction, meaning that\nthe code is more difficult to read.");
        // TODO add your handling code here:
    }//GEN-LAST:event_Cpp1MouseMoved

    private void Cpp1MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_Cpp1MouseExited
          jTextArea4.setText(""); // TODO add your handling code here: // TODO add your handling code here:
    }//GEN-LAST:event_Cpp1MouseExited

    private void C3MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_C3MouseMoved
        jTextArea5.setText("Originally developed by Microsoft to run on their .NET framework,\nC# (pronounced C-sharp) is based on C and C++. \nC# was originally designed to be easy to learn and use.\nObviously that makes it a simple language to start with.");
        // TODO add your handling code here:
    }//GEN-LAST:event_C3MouseMoved

    private void C3MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_C3MouseExited
        jTextArea5.setText("");// TODO add your handling code here:
    }//GEN-LAST:event_C3MouseExited

    private void HomeButtonMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_HomeButtonMouseMoved
        jLabel1.setText("Home");        // TODO add your handling code here:
    }//GEN-LAST:event_HomeButtonMouseMoved

    private void HomeButtonMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_HomeButtonMouseExited
        jLabel1.setText("");        // TODO add your handling code here:
    }//GEN-LAST:event_HomeButtonMouseExited

    private void Java1MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_Java1MouseMoved
       jLabel2.setText("Java");        // TODO add your handling code here:
               
    }//GEN-LAST:event_Java1MouseMoved

    private void Java1MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_Java1MouseExited
       jLabel2.setText("");     // TODO add your handling code here:
    }//GEN-LAST:event_Java1MouseExited

    private void CMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CMouseMoved
       jLabel8.setText("C");        // TODO add your handling code here:
    }//GEN-LAST:event_CMouseMoved

    private void CMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CMouseExited
       jLabel8.setText("");        // TODO add your handling code here:
    }//GEN-LAST:event_CMouseExited

    private void Python1MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_Python1MouseMoved
       jLabel15.setText("Python");        // TODO add your handling code here:
    }//GEN-LAST:event_Python1MouseMoved

    private void Python1MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_Python1MouseExited
       jLabel15.setText("");        // TODO add your handling code here:
    }//GEN-LAST:event_Python1MouseExited

    private void CppMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CppMouseMoved
       jLabel17.setText("C++");        // TODO add your handling code here:
    }//GEN-LAST:event_CppMouseMoved

    private void CppMouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_CppMouseExited
       jLabel17.setText("");        // TODO add your handling code here:
    }//GEN-LAST:event_CppMouseExited

    private void jButton2MouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton2MouseMoved
      jLabel19.setText("Exit");        // TODO add your handling code here:
    }//GEN-LAST:event_jButton2MouseMoved

    private void jButton2MouseExited(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButton2MouseExited
      jLabel19.setText("");        // TODO add your handling code here:
    }//GEN-LAST:event_jButton2MouseExited

    public void setContent(String heading)
    {
        try{
            StyledDocument doc=jTextPane1.getStyledDocument();
            StyledDocument doc1=jTextPane1.getStyledDocument();
            SimpleAttributeSet text=new SimpleAttributeSet();
            StyleConstants.setBold(text, true);
            StyleConstants.setFontSize(text, 36);
            doc.insertString(0, heading, text);
        }catch(BadLocationException e){
            System.out.println("Exception : "+e.getMessage());
        }
    }
   

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Learning_app SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Learning_app.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Learning_app.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Learning_app.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Learning_app.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Learning_app().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton C;
    private javax.swing.JButton C1;
    private javax.swing.JButton C2;
    private javax.swing.JButton C3;
    private javax.swing.JPanel CContent;
    private javax.swing.JButton Cpp;
    private javax.swing.JButton Cpp1;
    private javax.swing.JPanel CppContent;
    private javax.swing.JButton GetStarted;
    private javax.swing.JButton GetStarted1;
    private javax.swing.JButton GetStarted2;
    private javax.swing.JButton GetStarted3;
    private javax.swing.JPanel Home;
    private javax.swing.JButton HomeButton;
    private javax.swing.JButton Java;
    private javax.swing.JButton Java1;
    private javax.swing.JPanel JavaContent;
    private javax.swing.JButton Python;
    private javax.swing.JButton Python1;
    private javax.swing.JPanel PythonContent;
    private javax.swing.JPanel Unit1;
    private javax.swing.JButton cp1;
    private javax.swing.JButton j1;
    private javax.swing.JButton j10;
    private javax.swing.JButton j11;
    private javax.swing.JButton j12;
    private javax.swing.JButton j13;
    private javax.swing.JButton j14;
    private javax.swing.JButton j15;
    private javax.swing.JButton j16;
    private javax.swing.JButton j17;
    private javax.swing.JButton j18;
    private javax.swing.JButton j19;
    private javax.swing.JButton j2;
    private javax.swing.JButton j20;
    private javax.swing.JButton j21;
    private javax.swing.JButton j22;
    private javax.swing.JButton j24;
    private javax.swing.JButton j25;
    private javax.swing.JButton j26;
    private javax.swing.JButton j27;
    private javax.swing.JButton j28;
    private javax.swing.JButton j29;
    private javax.swing.JButton j3;
    private javax.swing.JButton j30;
    private javax.swing.JButton j31;
    private javax.swing.JButton j32;
    private javax.swing.JButton j34;
    private javax.swing.JButton j35;
    private javax.swing.JButton j36;
    private javax.swing.JButton j37;
    private javax.swing.JButton j38;
    private javax.swing.JButton j39;
    private javax.swing.JButton j4;
    private javax.swing.JButton j40;
    private javax.swing.JButton j41;
    private javax.swing.JButton j42;
    private javax.swing.JButton j43;
    private javax.swing.JButton j44;
    private javax.swing.JButton j5;
    private javax.swing.JButton j6;
    private javax.swing.JButton j7;
    private javax.swing.JButton j8;
    private javax.swing.JButton j9;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel17;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    private javax.swing.JTextArea jTextArea4;
    private javax.swing.JTextArea jTextArea5;
    private javax.swing.JTextPane jTextPane1;
    // End of variables declaration//GEN-END:variables
}
